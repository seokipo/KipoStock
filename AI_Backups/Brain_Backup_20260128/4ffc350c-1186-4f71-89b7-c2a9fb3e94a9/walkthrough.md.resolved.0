# Walkthrough - Fix Persistent Alarm Crash

I have fixed the crash that occurred when the alarm time was reached.

## Changes Made

### GUI Main
#### [Kipo_GUI_main.py](file:///d:/Work/Python/AutoBuy/KipoBuy_Gui/Kipo_GUI_main.py)
1. **Initialized `last_alarm_time`**: Added `self.last_alarm_time = None` to the [__init__](file:///d:/Work/Python/AutoBuy/KipoBuy_Gui/Kipo_main.py#10-18) method. This prevents an `AttributeError` during the market hour check.
2. **Removed Broken Code**: Deleted a leftover `else:` block in [start_alarm](file:///d:/Work/Python/AutoBuy/KipoBuy_Gui/Kipo_GUI_main.py#641-659) that referenced an undefined variable `sound_file`.

```diff:Kipo_GUI_main.py


import sys
import os
import asyncio
import json
import datetime
import traceback
from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                           QHBoxLayout, QLabel, QLineEdit, QPushButton, 
                           QTextEdit, QFrame, QGridLayout, QMessageBox, QGroupBox,
                           QScrollArea, QRadioButton, QButtonGroup, QCheckBox)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QObject, QTimer
from PyQt6.QtGui import QFont, QIcon, QColor, QPalette

# ê¸°ì¡´ ëª¨ë“ˆ ì„í¬íŠ¸

# ê¸°ì¡´ ëª¨ë“ˆ ì„í¬íŠ¸
from config import telegram_token
from chat_command import ChatCommand
from get_setting import get_setting, cached_setting
from market_hour import MarketHour

# ----------------- Worker Thread for Asyncio Loop -----------------
class WorkerSignals(QObject):
    log_signal = pyqtSignal(str)
    status_signal = pyqtSignal(str)  # ìƒíƒœ í‘œì‹œì¤„ ì—…ë°ì´íŠ¸ìš©

class AsyncWorker(QThread):
    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self.signals = WorkerSignals()
        self.loop = None
        self.chat_command = None
        self.keep_running = True

    def run(self):
        # Create a new event loop for this thread
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)
        
        # 1. Override tel_send logic
        import chat_command as chat_cmd_module
        
        def gui_log_send(text):
            self.signals.log_signal.emit(text)
        
        # Patch tel_send in chat_command
        chat_cmd_module.tel_send = gui_log_send
        
        # 2. Redirect stdout/stderr to capture prints from get_seq.py and others
        class StreamRedirector:
            def __init__(self, emitter):
                self.emitter = emitter
            def write(self, text):
                text = text.strip()
                if text:
                    self.emitter(text)
            def flush(self):
                pass
                
        sys.stdout = StreamRedirector(gui_log_send)
        sys.stderr = StreamRedirector(gui_log_send)

        # Initialize ChatCommand
        self.chat_command = ChatCommand()
        self.chat_command.rt_search.on_connection_closed = self._on_connection_closed_wrapper
        
        self.loop.run_until_complete(self.main_loop())
        self.loop.close()

    async def _on_connection_closed_wrapper(self):
        self.signals.log_signal.emit("âš ï¸ ì—°ê²° ëŠê¹€ ê°ì§€. ì¬ì—°ê²° ì‹œë„ ì¤‘...")
        await self.chat_command._on_connection_closed()

    async def main_loop(self):
        self.signals.log_signal.emit("ğŸš€ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ. ëŒ€ê¸° ì¤‘...")
        
        # ì„¤ì • ë¡œë“œ ë° ì ìš©
        self.load_initial_settings()
        
        # ì‹œì‘ ì‹œ ìë™ìœ¼ë¡œ ì¡°ê±´ì‹ ëª©ë¡ ê°€ì ¸ì˜¤ê¸° (ë§ˆì§€ë§‰ ì €ì¥ëœ ì„¤ì •ëŒ€ë¡œ í•„í„°ë§ë˜ì–´ í‘œì‹œë¨)
        self.signals.log_signal.emit("â„¹ï¸ ì €ì¥ëœ ì¡°ê±´ì‹ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤...")
        await self.chat_command.condition()
        
        try:
            while self.keep_running:
                # í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ í™•ì¸ (GUIì—ì„œëŠ” í•„ìˆ˜ ì•„ë‹˜, í…”ë ˆê·¸ë¨ ì œì–´ ì›í•  ì‹œ ìœ ì§€)
                message = self.get_chat_updates()
                if message:
                    await self.chat_command.process_command(message)
                
                
                # ì¥ ì‹œì‘/ì¢…ë£Œ ì‹œê°„ ìë™ í™•ì¸ ë¡œì§ (ì•ˆì „ ëª¨ë“œ: ì™„ì „ ë¹„í™œì„±í™”)
                
                await asyncio.sleep(0.1)
                
        except Exception as e:
            self.signals.log_signal.emit(f"âŒ ë©”ì¸ ë£¨í”„ ì—ëŸ¬: {e}")

    def load_initial_settings(self):
        try:
            with open('settings.json', 'r', encoding='utf-8') as f:
                settings = json.load(f)
                
            # ì‹œê°„ ì„¤ì • ì ìš© (settings.jsonì— ì‹œê°„ì´ ì—†ë‹¤ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©)
            start_time = settings.get('start_time', "09:00")
            end_time = settings.get('end_time', "15:20") # ì¥ ì¢…ë£Œ 10ë¶„ì „
            
            sh, sm = map(int, start_time.split(':'))
            eh, em = map(int, end_time.split(':'))
            
            MarketHour.set_market_hours(sh, sm, eh, em)
            self.signals.log_signal.emit(f"âš™ï¸ ì¥ ìš´ì˜ ì‹œê°„ ì„¤ì •: {start_time} ~ {end_time}")
            
        except Exception as e:
            self.signals.log_signal.emit(f"âš ï¸ ì„¤ì • ë¡œë“œ ì¤‘ ì˜¤ë¥˜ (ê¸°ë³¸ê°’ ì‚¬ìš©): {e}")

    # MainAppì˜ ë¡œì§ ê°€ì ¸ì˜´
    last_update_id = 0
    telegram_url = f"https://api.telegram.org/bot{telegram_token}/getUpdates"
    today_started = False
    today_stopped = False
    last_check_date = None

    def get_chat_updates(self):
        # ì‚¬ìš©ìì˜ ìš”ì²­ìœ¼ë¡œ í…”ë ˆê·¸ë¨ ëª…ë ¹ ìˆ˜ì‹  ê¸°ëŠ¥ ìƒëµ
        return None
            
    # check_market_timing ë©”ì„œë“œ ì œê±° (ìë™ ì¢…ë£Œ ì¶©ëŒ ë°©ì§€)

    # GUIì—ì„œ í˜¸ì¶œí•  ë¹„ë™ê¸° ëª…ë ¹ë“¤
    def schedule_command(self, cmd_type, *args):
        asyncio.run_coroutine_threadsafe(self._execute_command(cmd_type, *args), self.loop)

    async def _execute_command(self, cmd_type, *args):
        try:
            if cmd_type == 'start':
                await self.chat_command.start()
            elif cmd_type == 'stop':
                await self.chat_command.stop(True)
            elif cmd_type == 'report':
                await self.chat_command.report()
            elif cmd_type == 'custom':
                await self.chat_command.process_command(args[0])
            elif cmd_type == 'update_setting':
                # settings.json ì—…ë°ì´íŠ¸
                # [ìˆ˜ì •] search_seqë„ ë¦¬ìŠ¤íŠ¸ ê·¸ëŒ€ë¡œ ì €ì¥í•˜ë„ë¡ update_setting ì§ì ‘ í˜¸ì¶œ
                self.chat_command.update_setting(args[0], args[1])
                self.signals.log_signal.emit(f"âœ… ì„¤ì • ë³€ê²½: {args[0]} = {args[1]}")
                
            elif cmd_type == 'condition_list':
                await self.chat_command.condition() # ì¸ì ì—†ì´ í˜¸ì¶œí•˜ë©´ ëª©ë¡ ì¡°íšŒ
        except Exception as e:
            self.signals.log_signal.emit(f"âŒ ëª…ë ¹ ì‹¤í–‰ ì˜¤ë¥˜: {e}")

    def stop(self):
        self.keep_running = False
        self.wait()


# ----------------- Main Window -----------------
class KipoWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("KipoBuy Auto Trading System - V3.8.1 (Ultra Stable)")
        # íŒŒì¼ ê²½ë¡œ ì„¤ì • (ì¤‘ìš”: ë¦¬ì†ŒìŠ¤ì™€ ì„¤ì • íŒŒì¼ ë¶„ë¦¬)
        if getattr(sys, 'frozen', False):
            # ì‹¤í–‰ íŒŒì¼ ìœ„ì¹˜ (settings.json, ë¡œê·¸ ì €ì¥ìš©)
            self.script_dir = os.path.dirname(sys.executable)
            # ì„ì‹œ ë¦¬ì†ŒìŠ¤ ìœ„ì¹˜ (ì•„ì´ì½˜ ë“± ë²ˆë“¤ëœ íŒŒì¼ìš©)
            self.resource_dir = sys._MEIPASS
        else:
            self.script_dir = os.path.dirname(os.path.abspath(__file__))
            self.resource_dir = self.script_dir
            
        self.settings_file = os.path.join(self.script_dir, 'settings.json')

        # ì•„ì´ì½˜ ì„¤ì • (ë¦¬ì†ŒìŠ¤ ê²½ë¡œì—ì„œ ë¡œë“œ)
        icon_path = os.path.join(self.resource_dir, 'icon.png')
        if os.path.exists(icon_path):
            self.setWindowIcon(QIcon(icon_path))
        else:
            # Fallback checks
            icon_path_alt = os.path.join(self.script_dir, 'icon.png')
            if os.path.exists(icon_path_alt):
                self.setWindowIcon(QIcon(icon_path_alt))
                
        self.resize(1000, 700)
        
        self.setup_ui()
        self.setup_worker()
        self.load_settings_to_ui()

        # ì•ŒëŒ ê´€ë ¨ ì´ˆê¸°í™”
        self.alarm_playing = False
        self.app_start_time = datetime.datetime.now() # ì‹œì‘ ì‹œê°„ ê¸°ë¡ (ì•ˆì „ì¥ì¹˜)

        # ì•ŒëŒ ë°˜ë³µ íƒ€ì´ë¨¸ ì œê±° (ì†Œë¦¬ ê¸°ëŠ¥ ì™„ì „ ë¹„í™œì„±í™”)
        # self.sound_repeater = QTimer(self)
        
        self.alarm_timer = QTimer(self)
        self.alarm_timer.setInterval(1000) # 1ì´ˆë§ˆë‹¤ ì²´í¬
        self.alarm_timer.timeout.connect(self.check_alarm)
        self.alarm_timer.start()

    def setup_ui(self):
        # --- Styles ---
        self.setStyleSheet("""
            QMainWindow { background-color: #f0f2f5; }
            QGroupBox { font-weight: bold; border: 1px solid #ccc; border-radius: 8px; margin-top: 10px; padding-top: 15px; background-color: white; }
            QGroupBox::title { subcontrol-origin: margin; subcontrol-position: top left; left: 10px; padding: 0 5px; }
            QLabel { color: #333; }
            QLineEdit { padding: 5px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9; }
            
            /* ë²„íŠ¼ ìŠ¤íƒ€ì¼ì„ íŠ¹ì • í´ë˜ìŠ¤ë¡œ ì œí•œí•˜ê±°ë‚˜ QMessageBox ë²„íŠ¼ì„ ìœ„í•œ ì˜ˆì™¸ ì²˜ë¦¬ */
            QPushButton { padding: 8px 15px; border-radius: 5px; font-weight: bold; color: white; border: none; }
            QPushButton:hover { opacity: 0.9; }
            
            /* QMessageBox ë²„íŠ¼ ë³µêµ¬ */
            QMessageBox QPushButton {
                background-color: #007bff; /* íŒŒë€ìƒ‰ */
                color: white;
                border: 1px solid #0056b3;
                min-width: 60px;
            }
            QMessageBox QPushButton:hover {
                background-color: #0056b3;
            }
            
            QTextEdit { background-color: #1e1e1e; color: #00ff00; font-family: 'Consolas', 'Monospace'; border-radius: 5px; padding: 10px; }
        """)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        # Root Layout: Vertical (Header + Body)
        root_layout = QVBoxLayout(central_widget)
        root_layout.setContentsMargins(10, 10, 10, 10)
        root_layout.setSpacing(10)

        # === 0. Global Header ===
        header_widget = QWidget()
        header_layout = QHBoxLayout(header_widget)
        header_layout.setContentsMargins(0, 0, 0, 10)
        
        # Spacer to balance
        left_spacer = QWidget()
        left_spacer.setFixedWidth(40) 
        
        title_label = QLabel("ğŸš€ KipoStock V3.7 (Alarm)")
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_label.setFont(QFont("Arial", 20, QFont.Weight.Bold))
        title_label.setStyleSheet("color: #2c3e50;")
        
        # Always on Top Button (Pin icon)
        self.btn_top = QPushButton("ğŸ“Œ")
        self.btn_top.setCheckable(True)
        self.btn_top.setFixedSize(40, 40)
        self.btn_top.setToolTip("í•­ìƒ ìœ„ì— ê³ ì •")
        self.btn_top.setStyleSheet("""
            QPushButton { background-color: #f8f9fa; border-radius: 5px; font-size: 18px; border: 1px solid #ddd; color: #aaa; }
            QPushButton:checked { background-color: #17a2b8; color: white; border: 1px solid #138496; }
            QPushButton:hover { background-color: #e2e6ea; }
        """)
        self.btn_top.clicked.connect(self.toggle_always_on_top)
        
        header_layout.addWidget(left_spacer)
        header_layout.addStretch()
        header_layout.addWidget(title_label)
        header_layout.addStretch()
        header_layout.addWidget(self.btn_top)
        
        root_layout.addWidget(header_widget)

        # === Body Layout (Left + Right) ===
        body_layout = QHBoxLayout()
        body_layout.setContentsMargins(0, 0, 0, 0)
        body_layout.setSpacing(10)
        root_layout.addLayout(body_layout)

        # === Left Panel: Settings ===
        left_panel = QFrame()
        left_panel.setFixedWidth(280)
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(0, 0, 0, 0)
        
        # 1. Settings Group
        settings_group = QGroupBox("âš™ï¸ Settings")
        settings_layout = QVBoxLayout()
        settings_layout.setSpacing(12)

        # Condition Select (0-9)
        cond_label = QLabel("ì¡°ê±´ì‹ ì„ íƒ (0-9)")
        self.cond_btn_layout = QHBoxLayout()
        self.cond_buttons = []
        for i in range(10):
            btn = QPushButton(str(i))
            btn.setFixedSize(22, 22)
            btn.setCheckable(True)
            btn.setStyleSheet("""
                QPushButton { background-color: #e0e0e0; color: #333; padding: 0; font-size: 10px; }
                QPushButton:checked { background-color: #007bff; color: white; }
            """)
            btn.clicked.connect(lambda checked, idx=i: self.on_cond_clicked(idx))
            self.cond_buttons.append(btn)
            self.cond_btn_layout.addWidget(btn)
        
        settings_layout.addWidget(cond_label)
        settings_layout.addLayout(self.cond_btn_layout)

        # Profit & Loss (Horizontal)
        pl_layout = QHBoxLayout()
        
        # Profit
        pl_layout.addWidget(QLabel("ìµì ˆ"))
        self.input_profit = QLineEdit()
        self.input_profit.setFixedWidth(60)
        pl_layout.addWidget(self.input_profit)
        
        pl_layout.addSpacing(10)
        
        # Loss
        pl_layout.addWidget(QLabel("ì†ì ˆ"))
        self.input_loss = QLineEdit()
        self.input_loss.setFixedWidth(60)
        pl_layout.addWidget(self.input_loss)
        
        pl_layout.addStretch() # Push to left
        settings_layout.addLayout(pl_layout)

        # Max Stocks
        settings_layout.addWidget(QLabel("ìµœëŒ€ ë³´ìœ  ì¢…ëª© ìˆ˜"))
        self.input_max = QLineEdit()
        settings_layout.addWidget(self.input_max)

        # Time Settings (Horizontal)
        time_layout = QHBoxLayout()
        
        # Start
        time_layout.addWidget(QLabel("ì‹œì‘"))
        self.input_start_time = QLineEdit()
        self.input_start_time.setFixedWidth(60)
        self.input_start_time.setAlignment(Qt.AlignmentFlag.AlignCenter)
        time_layout.addWidget(self.input_start_time)
        
        time_layout.addSpacing(10)
        
        # End
        time_layout.addWidget(QLabel("ì¢…ë£Œ"))
        self.input_end_time = QLineEdit()
        self.input_end_time.setFixedWidth(60)
        self.input_end_time.setAlignment(Qt.AlignmentFlag.AlignCenter)
        time_layout.addWidget(self.input_end_time)
        
        time_layout.addWidget(self.input_end_time)
        
        # ğŸ”” ì•ŒëŒ í•´ì œ ë²„íŠ¼
        self.btn_alarm_stop = QPushButton("ğŸ”•")
        self.btn_alarm_stop.setToolTip("ì•ŒëŒ í•´ì œ")
        self.btn_alarm_stop.setStyleSheet("""
            QPushButton {
                background-color: #dc3545; 
                color: white; 
                font-weight: bold;
                border: none;
                border-radius: 4px;
                padding: 4px 8px;
                font-size: 16px;
            }
            QPushButton:disabled {
                background-color: #e2e6ea;
                color: #adb5bd;
            }
        """)
        self.btn_alarm_stop.setFixedWidth(50)
        self.btn_alarm_stop.clicked.connect(self.stop_alarm)
        self.btn_alarm_stop.setEnabled(False) # ê¸°ë³¸ì€ ë¹„í™œì„±í™”
        self.btn_alarm_stop.setVisible(True)
        time_layout.addWidget(self.btn_alarm_stop)
        
        time_layout.addStretch()
        settings_layout.addLayout(time_layout)

        # ğŸ’ Global Buy Strategy Group
        strategy_group = QGroupBox("ğŸ’ ë§¤ìˆ˜ ì „ëµ (Buying Strategy)")
        strategy_group.setStyleSheet("""
            QGroupBox { 
                background-color: #ffffff; 
                border: 2px solid #007bff; 
                border-radius: 8px; 
                margin-top: 15px; 
                font-weight: bold;
                color: #007bff;
            }
        """)
        strat_layout = QVBoxLayout()
        strat_layout.setSpacing(10)

        # 1. Mode Selection (Radio)
        mode_layout = QHBoxLayout()
        self.rb_qty = QRadioButton("1ì£¼")
        self.rb_amount = QRadioButton("ê¸ˆì•¡")
        self.rb_percent = QRadioButton("ë¹„ìœ¨")
        
        self.bg_mode = QButtonGroup()
        self.bg_mode.addButton(self.rb_qty)
        self.bg_mode.addButton(self.rb_amount)
        self.bg_mode.addButton(self.rb_percent)
        
        # Default
        self.rb_qty.setChecked(True) 
        
        # Style
        for rb in [self.rb_qty, self.rb_amount, self.rb_percent]:
            rb.setStyleSheet("font-weight: bold; color: #333;")

        mode_layout.addWidget(self.rb_qty)
        mode_layout.addWidget(self.rb_amount)
        mode_layout.addWidget(self.rb_percent)
        strat_layout.addLayout(mode_layout)
        
        # 2. Value Input
        input_layout = QHBoxLayout()
        input_layout.addWidget(QLabel("ì„¤ì •ê°’:"))
        self.input_strategy_value = QLineEdit("1")
        self.input_strategy_value.setStyleSheet("""
            QLineEdit { 
                padding: 8px; 
                font-size: 14px; 
                border: 2px solid #ddd; 
                border-radius: 6px; 
                background-color: #f0f8ff;
                font-weight: bold;
                color: #000;
            }
            QLineEdit:focus { border: 2px solid #007bff; }
            QLineEdit:disabled { background-color: #e9ecef; color: #6c757d; }
        """)
        self.input_strategy_value.setAlignment(Qt.AlignmentFlag.AlignCenter)
        input_layout.addWidget(self.input_strategy_value)
        
        # Unit Label (ì£¼/ì›/%)
        self.lbl_unit = QLabel("ì£¼")
        self.lbl_unit.setStyleSheet("font-weight: bold; font-size: 14px; margin-left: 5px;")
        input_layout.addWidget(self.lbl_unit)
        
        strat_layout.addLayout(input_layout)
        
        # Helper text Removed
        
        # Event connections for UI feedback
        # Use lambda to differentiate user clicks vs programmatic changes if needed, but simple connect is fine here
        self.rb_qty.clicked.connect(lambda: self.update_strategy_ui(True)) 
        self.rb_amount.clicked.connect(lambda: self.update_strategy_ui(True))
        self.rb_percent.clicked.connect(lambda: self.update_strategy_ui(True))
        
        # Input Text Changed for Comma Formatting
        self.input_strategy_value.textEdited.connect(self.format_input_value)

        strategy_group.setLayout(strat_layout)
        settings_layout.addWidget(strategy_group)

        # Save Button
        btn_save = QPushButton("ğŸ’¾ ì„¤ì • ì €ì¥")
        btn_save.setStyleSheet("background-color: #6c757d; margin-top: 10px;")
        btn_save.clicked.connect(self.save_settings)
        settings_layout.addWidget(btn_save)
        
        settings_group.setLayout(settings_layout)
        left_layout.addWidget(settings_group)

        # 2. Real-time List
        rt_group = QGroupBox("ğŸ“‹ ì‹¤ì‹œê°„ ì¡°ê±´ì‹")
        rt_layout = QVBoxLayout()
        self.rt_list = QTextEdit()
        self.rt_list.setReadOnly(True)
        self.rt_list.setStyleSheet("background-color: white; color: black; border: 1px solid #ddd;")
        rt_layout.addWidget(self.rt_list)
        
        # ëª©ë¡ ê°±ì‹  ë²„íŠ¼ ì‚­ì œ (ì„¤ì • ì €ì¥ ì‹œ ìë™ ì‹¤í–‰)
        # btn_refresh = QPushButton("ğŸ”„ ëª©ë¡ ê°±ì‹ ")
        # btn_refresh.setStyleSheet("background-color: #fff; color: #333; border: 1px solid #ccc;")
        # btn_refresh.clicked.connect(lambda: self.worker.schedule_command('condition_list'))
        # rt_layout.addWidget(btn_refresh)
        
        rt_group.setLayout(rt_layout)
        left_layout.addWidget(rt_group)

        # === Right Panel: Controls & Logs ===

        right_panel = QFrame()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)

        # Header Layout Removed (Moved to Global)

        # Control Buttons
        btn_layout = QHBoxLayout()
        
        self.btn_start = QPushButton("â–¶ START")
        self.btn_start.setStyleSheet("background-color: #28a745; height: 35px; font-size: 14px;")
        self.btn_start.clicked.connect(lambda: self.worker.schedule_command('start'))
        
        self.btn_stop = QPushButton("â¹ STOP")
        self.btn_stop.setStyleSheet("background-color: #dc3545; height: 35px; font-size: 14px;")
        self.btn_stop.clicked.connect(lambda: self.worker.schedule_command('stop'))
        
        self.btn_report = QPushButton("ğŸ“Š REPORT")
        self.btn_report.setStyleSheet("background-color: #17a2b8; height: 35px; font-size: 14px;")
        self.btn_report.clicked.connect(lambda: self.worker.schedule_command('report'))

        btn_layout.addWidget(self.btn_start)
        btn_layout.addWidget(self.btn_stop)
        btn_layout.addWidget(self.btn_report)
        right_layout.addLayout(btn_layout)

        # System Log
        log_group = QGroupBox("ğŸ“„ System Logs")
        log_layout = QVBoxLayout()
        self.log_text = QTextEdit()
        self.log_text.setReadOnly(True)
        log_layout.addWidget(self.log_text)
        log_group.setLayout(log_layout)
        right_layout.addWidget(log_group)

        # Command Input
        input_layout = QHBoxLayout()
        input_label = QLabel("ëª…ë ¹ì–´ ì…ë ¥:")
        self.cmd_input = QLineEdit()
        self.cmd_input.returnPressed.connect(self.send_command)
        
        btn_send = QPushButton("ì „ì†¡")
        btn_send.setStyleSheet("background-color: #fff; color: #333; border: 1px solid #ccc;")
        btn_send.clicked.connect(self.send_command)

        input_layout.addWidget(input_label)
        input_layout.addWidget(self.cmd_input)
        input_layout.addWidget(btn_send)
        right_layout.addLayout(input_layout)

        # Add panels to body layout
        body_layout.addWidget(left_panel)
        body_layout.addWidget(right_panel)
        body_layout.setStretch(1, 1) # Right panel takes remaining space

    def setup_worker(self):
        self.worker = AsyncWorker(self)
        self.worker.signals.log_signal.connect(self.append_log)
        self.worker.start()

    def append_log(self, text):
        timestamp = datetime.datetime.now().strftime("%H:%M:%S")
        self.log_text.append(f"[{timestamp}] {text}")
        
        # ì¡°ê±´ì‹ ëª©ë¡ì´ë©´ ì™¼ìª½ íŒ¨ë„ì—ëŠ” **ì„ íƒëœ ì¡°ê±´ì‹ë§Œ** í•„í„°ë§í•˜ì—¬ í‘œì‹œ
        if "ğŸ“‹ [ì¡°ê±´ì‹ ëª©ë¡]" in text:
            filtered_msg = ""
            lines = text.split('\n')
            
            # í˜„ì¬ UIì—ì„œ ì²´í¬ëœ ë²ˆí˜¸ë“¤ ê°€ì ¸ì˜¤ê¸°
            checked_indices = [str(i) for i, btn in enumerate(self.cond_buttons) if btn.isChecked()]
            
            found_any = False
            for line in lines:
                if line.startswith('â€¢'):
                    # í¬ë§·: "â€¢ 0: ì¡°ê±´ì‹ì´ë¦„" -> ":" ê¸°ì¤€ìœ¼ë¡œ ë¶„ë¦¬
                    try:
                        parts = line.split(':')
                        idx = parts[0].replace('â€¢', '').strip()
                        
                        if idx in checked_indices:
                            filtered_msg += line + "\n"
                            found_any = True
                    except:
                        pass
            
            if not found_any:
                filtered_msg += "(ì„ íƒëœ ì¡°ê±´ì‹ì´ ëª©ë¡ì— ì—†ìŠµë‹ˆë‹¤)"
                
            self.rt_list.setText(filtered_msg)
            
        # Auto scroll
        sb = self.log_text.verticalScrollBar()
        sb.setValue(sb.maximum())


    def send_command(self):
        cmd = self.cmd_input.text().strip()
        if cmd:
            if cmd.upper() == 'PRINT':
                self.export_log()
            else:
                self.worker.schedule_command('custom', cmd)
            self.cmd_input.clear()

    def export_log(self):
        try:
            now_str = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"KIPOSTOCK_LOG_{now_str}.txt"
            
            # í˜„ì¬ ì‹¤í–‰ íŒŒì¼ ìœ„ì¹˜ì— ì €ì¥
            log_path = os.path.join(self.script_dir, filename)
            
            content = self.log_text.toPlainText()
            
            with open(log_path, 'w', encoding='utf-8') as f:
                f.write(content)
                
            self.append_log(f"ğŸ’¾ ë¡œê·¸ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤: {filename}")
            
            # ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼ (ì„ íƒ ì‚¬í•­)
            # QMessageBox.information(self, "ë¡œê·¸ ì €ì¥", f"ë¡œê·¸ê°€ íŒŒì¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.\n{filename}")
            
        except Exception as e:
            self.append_log(f"âŒ ë¡œê·¸ ì €ì¥ ì‹¤íŒ¨: {e}")

    def on_cond_clicked(self, idx):
        # ë‹¨ìˆœíˆ UI ìƒíƒœë§Œ ë³€ê²½ (ì„¤ì • ì €ì¥ ì‹œ ë°˜ì˜)
        pass

    # --- ì•ŒëŒ ë¡œì§ ---
    def check_alarm(self):
        # ì´ë¯¸ ìš¸ë¦¬ê³  ìˆìœ¼ë©´ íŒ¨ìŠ¤
        if self.alarm_playing:
            return

        # í”„ë¡œê·¸ë¨ ì‹œì‘ í›„ 5ì´ˆê°„ì€ ì•ŒëŒ ì²´í¬ ìŠ¤í‚µ (ì´ˆê¸°í™” ì•ˆì •í™” ëŒ€ê¸°)
        if (datetime.datetime.now() - self.app_start_time).total_seconds() < 5:
            return

        current_time = datetime.datetime.now().strftime("%H:%M")
        end_time_str = self.input_end_time.text().strip()
        
        # ì‹œê°„ì´ ì¼ì¹˜í•˜ê³ , ë°©ê¸ˆ ëˆ ì‹œê°„ì´ ì•„ë‹ˆë¼ë©´ ìš¸ë¦¼
        if current_time == end_time_str:
            if self.last_alarm_time != current_time:
                self.start_alarm()

    def start_alarm(self):
        if self.alarm_playing:
            return
            
        try:
            self.alarm_playing = True
            
            # ë²„íŠ¼ ìƒíƒœ ë³€ê²½ (ê°€ì¥ ì•ˆì „í•œ ë°©ì‹)
            self.btn_alarm_stop.setEnabled(True)
            self.btn_alarm_stop.setText("ğŸ””") # ì•„ì´ì½˜ ëŒ€ì‹  í…ìŠ¤íŠ¸ë¡œ í…ŒìŠ¤íŠ¸
            
            log_msg = f"â° ì•ŒëŒ ë°œìƒ: ì¢…ë£Œ ì‹œê°„({self.input_end_time.text()}) ë„ë‹¬!"
            self.append_log(log_msg)
            print(log_msg)
            
        except Exception as e:
            print(f"âš ï¸ ì•ŒëŒ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {e}")
            self.alarm_playing = False 
                
 
        else:
             if not getattr(self, '_alarm_missing_logged', False):
                 self.append_log(f"âš ï¸ ì•ŒëŒ íŒŒì¼ ì—†ìŒ: {sound_file}")
                 self._alarm_missing_logged = True

    # def play_subprocess_sound(self):  <-- ë©”ì„œë“œ ì œê±°
    #     pass

    def stop_alarm(self):
        if self.alarm_playing:
            # self.sound_repeater.stop()
            self.alarm_playing = False
            self.last_alarm_time = datetime.datetime.now().strftime("%H:%M") # í˜„ì¬ ë¶„ì—ëŠ” ë‹¤ì‹œ ì•ˆ ìš¸ë¦¼
            
            self.btn_alarm_stop.setEnabled(False)
            self.btn_alarm_stop.setStyleSheet("""
                QPushButton {
                    background-color: #dc3545; 
                    color: white; 
                    font-weight: bold;
                    border: none;
                    border-radius: 4px;
                    padding: 4px 8px;
                    font-size: 16px;
                }
                QPushButton:disabled {
                    background-color: #e2e6ea;
                    color: #adb5bd;
                }
            """)
            self.append_log("ğŸ”• ì•ŒëŒì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.")

    def update_strategy_ui(self, from_user_click=False):
        if self.rb_qty.isChecked():
            self.lbl_unit.setText("ì£¼")
            self.input_strategy_value.setText("1")
            self.input_strategy_value.setEnabled(False) # Disable input
            
        elif self.rb_amount.isChecked():
            self.lbl_unit.setText("ì›")
            self.input_strategy_value.setEnabled(True)
            self.input_strategy_value.setPlaceholderText("ì˜ˆ: 100,000")
            if from_user_click:
                 self.input_strategy_value.setText("100,000") # Default

        elif self.rb_percent.isChecked():
            self.lbl_unit.setText("%")
            self.input_strategy_value.setEnabled(True)
            self.input_strategy_value.setPlaceholderText("ì˜ˆ: 10")
            if from_user_click:
                 self.input_strategy_value.setText("10") # Default
                 
    def format_input_value(self, text):
        if self.rb_amount.isChecked():
            # Remove existing commas
            plain_text = text.replace(',', '')
            if plain_text.isdigit():
                formatted = f"{int(plain_text):,}"
                self.input_strategy_value.setText(formatted)
        else:
            # For percent/qty, no formatting needed usually, maybe float check?
            pass

    def load_settings_to_ui(self):
        try:
            with open(self.settings_file, 'r', encoding='utf-8') as f:
                settings = json.load(f)
            
            self.input_profit.setText(str(settings.get('take_profit_rate', '12.0')))
            self.input_loss.setText(str(settings.get('stop_loss_rate', '-1.2')))
            self.input_max.setText(str(settings.get('max_stocks', '20')))
            
            # Condition Button Set - Support Multiple Selection
            seq_data = settings.get('search_seq', [])
            
            # [ìˆ˜ì •] Robust parsing for search_seq
            if isinstance(seq_data, str):
                try:
                    # If it's a string representation of a list like "['0', '1']"
                    parsed = ast.literal_eval(seq_data)
                    if isinstance(parsed, list):
                        seq_data = parsed
                    else:
                        seq_data = [seq_data]
                except:
                    # Not a list-string, just a regular string
                    seq_data = [seq_data]
            elif isinstance(seq_data, int):
                seq_data = [str(seq_data)]
                
            # Convert to set of strings for easy lookup
            seq_set = set(map(str, seq_data))
            
            for i, btn in enumerate(self.cond_buttons):
                if str(i) in seq_set:
                    btn.setChecked(True)
                else:
                    btn.setChecked(False)
            
            # Times (if exist in settings, else default)
            self.input_start_time.setText(settings.get('start_time', '09:00'))
            self.input_end_time.setText(settings.get('end_time', '15:20'))
            
            # Special Buy Settings -> Global Strategy Settings
            mode = settings.get('global_strategy_mode', 'qty')
            val = settings.get('global_strategy_value', '1')
            scope = settings.get('global_strategy_scope', 'all')
            
            if mode == 'amount':
                self.rb_amount.setChecked(True)
            elif mode == 'percent':
                self.rb_percent.setChecked(True)
            else:
                self.rb_qty.setChecked(True)
                
            self.input_strategy_value.setText(str(val))
            
            # Legacy values check (if user saves new settings those will override)
            if mode == 'qty':
                 self.rb_qty.setChecked(True)
            elif mode == 'amount':
                 self.rb_amount.setChecked(True)
                 # Format saved value with comma
                 try:
                     val = f"{int(str(val).replace(',', '')):,}"
                 except: pass
            elif mode == 'percent':
                 self.rb_percent.setChecked(True)
                 
            self.input_strategy_value.setText(str(val))
            self.update_strategy_ui(False) # Update state but don't reset defaults
            
        except Exception as e:
            self.append_log(f"ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: {e}")

    def save_settings(self):
        try:
            # UI ê°’ ì½ê¸°
            tpr = self.input_profit.text()
            slr = self.input_loss.text()
            max_s = self.input_max.text()
            st = self.input_start_time.text()
            et = self.input_end_time.text()
            
            # ì¡°ê±´ì‹ ì„ íƒ ìƒíƒœ ì½ê¸° (ì¤‘ìš”: selected_seq ë³€ìˆ˜ ìƒì„±)
            selected_seq = []
            for i, btn in enumerate(self.cond_buttons):
                if btn.isChecked():
                    selected_seq.append(str(i))

            # Global Strategy Settings
            st_mode = 'qty'
            if self.rb_amount.isChecked(): st_mode = 'amount'
            elif self.rb_percent.isChecked(): st_mode = 'percent'
            
            st_val = self.input_strategy_value.text()
            # Scope is now ALWAYS 'all'
            st_scope = 'all'
            
            self.worker.schedule_command('update_setting', 'global_strategy_mode', st_mode)
            self.worker.schedule_command('update_setting', 'global_strategy_value', st_val)
            self.worker.schedule_command('update_setting', 'global_strategy_scope', st_scope)
            
            # Workerë¥¼ í†µí•´ ì—…ë°ì´íŠ¸
            self.worker.schedule_command('update_setting', 'take_profit_rate', float(tpr))
            self.worker.schedule_command('update_setting', 'stop_loss_rate', float(slr))
            self.worker.schedule_command('update_setting', 'max_stocks', int(max_s))
            self.worker.schedule_command('update_setting', 'start_time', st)
            self.worker.schedule_command('update_setting', 'end_time', et)
            
            # Legacy cleanup (optional but good practice to clear old keys or just ignore them)
            # For now, we just overwrite the new keys.
            
            # ì¡°ê±´ì‹ ë¦¬ìŠ¤íŠ¸ ì €ì¥
            self.worker.schedule_command('update_setting', 'search_seq', selected_seq)
            
            # ì‹œê°„ ì„¤ì • ì¦‰ì‹œ ë°˜ì˜
            sh, sm = map(int, st.split(':'))
            eh, em = map(int, et.split(':'))
            MarketHour.set_market_hours(sh, sm, eh, em)
            
            # ëª©ë¡ ê°±ì‹  ìë™ ì‹¤í–‰
            self.worker.schedule_command('condition_list')
            
            # [ì‹ ê·œ] ì €ì¥ ì‹œ ìºì‹œ ì´ˆê¸°í™” (ì¦‰ì‹œ ë°˜ì˜ ìœ„í•¨)
            if hasattr(cached_setting, "_cache"):
                cached_setting._cache = {}
                print("ğŸ§¹ ì„¤ì • ìºì‹œ ì´ˆê¸°í™” ì™„ë£Œ")
            
            QMessageBox.information(self, "ì €ì¥ ì™„ë£Œ", "ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.\nì‹¤ì‹œê°„ ì¡°ê±´ì‹ ëª©ë¡ë„ ê°±ì‹ ë©ë‹ˆë‹¤.")
            
        except ValueError:
            QMessageBox.warning(self, "ì…ë ¥ ì˜¤ë¥˜", "ìˆ«ì í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.")
        except Exception as e:
             QMessageBox.critical(self, "ì˜¤ë¥˜", f"ì €ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")

    def toggle_always_on_top(self, checked):
        if checked:
            self.setWindowFlag(Qt.WindowType.WindowStaysOnTopHint, True)
            self.show()
        else:
            self.setWindowFlag(Qt.WindowType.WindowStaysOnTopHint, False)
            self.show()

    def closeEvent(self, event):
        reply = QMessageBox.question(self, 'ì¢…ë£Œ', 'í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?',
                                   QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, 
                                   QMessageBox.StandardButton.No)

        if reply == QMessageBox.StandardButton.Yes:
            self.worker.stop()
            event.accept()
        else:
            event.ignore()

if __name__ == '__main__':
    try:
        app = QApplication(sys.argv)
        
        # Font Setup
        font = QFont("Malgun Gothic", 9)
        app.setFont(font)
        
        window = KipoWindow()
        window.show()
        
        retCode = app.exec()
        sys.exit(retCode)
        
    except BaseException as e:
        # BaseExceptionì„ í†µí•´ SystemExitê¹Œì§€ ëª¨ë‘ ìº¡ì²˜
        with open("crash_report.txt", "a", encoding="utf-8") as f:
            f.write(f"\n[{datetime.datetime.now()}] CRASH/EXIT LOGGED:\n")
            f.write(traceback.format_exc())
            f.write(f"Error Type: {type(e)}\n")
            f.write("-" * 50 + "\n")
        
        if not isinstance(e, SystemExit):
            print(f"CRITICAL ERROR (Logged to crash_report.txt): {e}")
            input("Press Enter to exit...")
===


import sys
import os
import asyncio
import json
import datetime
import traceback
from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                           QHBoxLayout, QLabel, QLineEdit, QPushButton, 
                           QTextEdit, QFrame, QGridLayout, QMessageBox, QGroupBox,
                           QScrollArea, QRadioButton, QButtonGroup, QCheckBox)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QObject, QTimer
from PyQt6.QtGui import QFont, QIcon, QColor, QPalette

# ê¸°ì¡´ ëª¨ë“ˆ ì„í¬íŠ¸

# ê¸°ì¡´ ëª¨ë“ˆ ì„í¬íŠ¸
from config import telegram_token
from chat_command import ChatCommand
from get_setting import get_setting, cached_setting
from market_hour import MarketHour

# ----------------- Worker Thread for Asyncio Loop -----------------
class WorkerSignals(QObject):
    log_signal = pyqtSignal(str)
    status_signal = pyqtSignal(str)  # ìƒíƒœ í‘œì‹œì¤„ ì—…ë°ì´íŠ¸ìš©

class AsyncWorker(QThread):
    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self.signals = WorkerSignals()
        self.loop = None
        self.chat_command = None
        self.keep_running = True

    def run(self):
        # Create a new event loop for this thread
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)
        
        # 1. Override tel_send logic
        import chat_command as chat_cmd_module
        
        def gui_log_send(text):
            self.signals.log_signal.emit(text)
        
        # Patch tel_send in chat_command
        chat_cmd_module.tel_send = gui_log_send
        
        # 2. Redirect stdout/stderr to capture prints from get_seq.py and others
        class StreamRedirector:
            def __init__(self, emitter):
                self.emitter = emitter
            def write(self, text):
                text = text.strip()
                if text:
                    self.emitter(text)
            def flush(self):
                pass
                
        sys.stdout = StreamRedirector(gui_log_send)
        sys.stderr = StreamRedirector(gui_log_send)

        # Initialize ChatCommand
        self.chat_command = ChatCommand()
        self.chat_command.rt_search.on_connection_closed = self._on_connection_closed_wrapper
        
        self.loop.run_until_complete(self.main_loop())
        self.loop.close()

    async def _on_connection_closed_wrapper(self):
        self.signals.log_signal.emit("âš ï¸ ì—°ê²° ëŠê¹€ ê°ì§€. ì¬ì—°ê²° ì‹œë„ ì¤‘...")
        await self.chat_command._on_connection_closed()

    async def main_loop(self):
        self.signals.log_signal.emit("ğŸš€ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ. ëŒ€ê¸° ì¤‘...")
        
        # ì„¤ì • ë¡œë“œ ë° ì ìš©
        self.load_initial_settings()
        
        # ì‹œì‘ ì‹œ ìë™ìœ¼ë¡œ ì¡°ê±´ì‹ ëª©ë¡ ê°€ì ¸ì˜¤ê¸° (ë§ˆì§€ë§‰ ì €ì¥ëœ ì„¤ì •ëŒ€ë¡œ í•„í„°ë§ë˜ì–´ í‘œì‹œë¨)
        self.signals.log_signal.emit("â„¹ï¸ ì €ì¥ëœ ì¡°ê±´ì‹ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤...")
        await self.chat_command.condition()
        
        try:
            while self.keep_running:
                # í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ í™•ì¸ (GUIì—ì„œëŠ” í•„ìˆ˜ ì•„ë‹˜, í…”ë ˆê·¸ë¨ ì œì–´ ì›í•  ì‹œ ìœ ì§€)
                message = self.get_chat_updates()
                if message:
                    await self.chat_command.process_command(message)
                
                
                # ì¥ ì‹œì‘/ì¢…ë£Œ ì‹œê°„ ìë™ í™•ì¸ ë¡œì§ (ì•ˆì „ ëª¨ë“œ: ì™„ì „ ë¹„í™œì„±í™”)
                
                await asyncio.sleep(0.1)
                
        except Exception as e:
            self.signals.log_signal.emit(f"âŒ ë©”ì¸ ë£¨í”„ ì—ëŸ¬: {e}")

    def load_initial_settings(self):
        try:
            with open('settings.json', 'r', encoding='utf-8') as f:
                settings = json.load(f)
                
            # ì‹œê°„ ì„¤ì • ì ìš© (settings.jsonì— ì‹œê°„ì´ ì—†ë‹¤ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©)
            start_time = settings.get('start_time', "09:00")
            end_time = settings.get('end_time', "15:20") # ì¥ ì¢…ë£Œ 10ë¶„ì „
            
            sh, sm = map(int, start_time.split(':'))
            eh, em = map(int, end_time.split(':'))
            
            MarketHour.set_market_hours(sh, sm, eh, em)
            self.signals.log_signal.emit(f"âš™ï¸ ì¥ ìš´ì˜ ì‹œê°„ ì„¤ì •: {start_time} ~ {end_time}")
            
        except Exception as e:
            self.signals.log_signal.emit(f"âš ï¸ ì„¤ì • ë¡œë“œ ì¤‘ ì˜¤ë¥˜ (ê¸°ë³¸ê°’ ì‚¬ìš©): {e}")

    # MainAppì˜ ë¡œì§ ê°€ì ¸ì˜´
    last_update_id = 0
    telegram_url = f"https://api.telegram.org/bot{telegram_token}/getUpdates"
    today_started = False
    today_stopped = False
    last_check_date = None

    def get_chat_updates(self):
        # ì‚¬ìš©ìì˜ ìš”ì²­ìœ¼ë¡œ í…”ë ˆê·¸ë¨ ëª…ë ¹ ìˆ˜ì‹  ê¸°ëŠ¥ ìƒëµ
        return None
            
    # check_market_timing ë©”ì„œë“œ ì œê±° (ìë™ ì¢…ë£Œ ì¶©ëŒ ë°©ì§€)

    # GUIì—ì„œ í˜¸ì¶œí•  ë¹„ë™ê¸° ëª…ë ¹ë“¤
    def schedule_command(self, cmd_type, *args):
        asyncio.run_coroutine_threadsafe(self._execute_command(cmd_type, *args), self.loop)

    async def _execute_command(self, cmd_type, *args):
        try:
            if cmd_type == 'start':
                await self.chat_command.start()
            elif cmd_type == 'stop':
                await self.chat_command.stop(True)
            elif cmd_type == 'report':
                await self.chat_command.report()
            elif cmd_type == 'custom':
                await self.chat_command.process_command(args[0])
            elif cmd_type == 'update_setting':
                # settings.json ì—…ë°ì´íŠ¸
                # [ìˆ˜ì •] search_seqë„ ë¦¬ìŠ¤íŠ¸ ê·¸ëŒ€ë¡œ ì €ì¥í•˜ë„ë¡ update_setting ì§ì ‘ í˜¸ì¶œ
                self.chat_command.update_setting(args[0], args[1])
                self.signals.log_signal.emit(f"âœ… ì„¤ì • ë³€ê²½: {args[0]} = {args[1]}")
                
            elif cmd_type == 'condition_list':
                await self.chat_command.condition() # ì¸ì ì—†ì´ í˜¸ì¶œí•˜ë©´ ëª©ë¡ ì¡°íšŒ
        except Exception as e:
            self.signals.log_signal.emit(f"âŒ ëª…ë ¹ ì‹¤í–‰ ì˜¤ë¥˜: {e}")

    def stop(self):
        self.keep_running = False
        self.wait()


# ----------------- Main Window -----------------
class KipoWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("KipoBuy Auto Trading System - V3.8.1 (Ultra Stable)")
        # íŒŒì¼ ê²½ë¡œ ì„¤ì • (ì¤‘ìš”: ë¦¬ì†ŒìŠ¤ì™€ ì„¤ì • íŒŒì¼ ë¶„ë¦¬)
        if getattr(sys, 'frozen', False):
            # ì‹¤í–‰ íŒŒì¼ ìœ„ì¹˜ (settings.json, ë¡œê·¸ ì €ì¥ìš©)
            self.script_dir = os.path.dirname(sys.executable)
            # ì„ì‹œ ë¦¬ì†ŒìŠ¤ ìœ„ì¹˜ (ì•„ì´ì½˜ ë“± ë²ˆë“¤ëœ íŒŒì¼ìš©)
            self.resource_dir = sys._MEIPASS
        else:
            self.script_dir = os.path.dirname(os.path.abspath(__file__))
            self.resource_dir = self.script_dir
            
        self.settings_file = os.path.join(self.script_dir, 'settings.json')

        # ì•„ì´ì½˜ ì„¤ì • (ë¦¬ì†ŒìŠ¤ ê²½ë¡œì—ì„œ ë¡œë“œ)
        icon_path = os.path.join(self.resource_dir, 'icon.png')
        if os.path.exists(icon_path):
            self.setWindowIcon(QIcon(icon_path))
        else:
            # Fallback checks
            icon_path_alt = os.path.join(self.script_dir, 'icon.png')
            if os.path.exists(icon_path_alt):
                self.setWindowIcon(QIcon(icon_path_alt))
                
        self.resize(1000, 700)
        
        self.setup_ui()
        self.setup_worker()
        self.load_settings_to_ui()

        # ì•ŒëŒ ê´€ë ¨ ì´ˆê¸°í™”
        self.alarm_playing = False
        self.last_alarm_time = None # ì´ì „ ì•ŒëŒ ë°œìƒ ì‹œê°„ (ì¤‘ë³µ ë°œìƒ ë°©ì§€)
        self.app_start_time = datetime.datetime.now() # ì‹œì‘ ì‹œê°„ ê¸°ë¡ (ì•ˆì „ì¥ì¹˜)

        # ì•ŒëŒ ë°˜ë³µ íƒ€ì´ë¨¸ ì œê±° (ì†Œë¦¬ ê¸°ëŠ¥ ì™„ì „ ë¹„í™œì„±í™”)
        # self.sound_repeater = QTimer(self)
        
        self.alarm_timer = QTimer(self)
        self.alarm_timer.setInterval(1000) # 1ì´ˆë§ˆë‹¤ ì²´í¬
        self.alarm_timer.timeout.connect(self.check_alarm)
        self.alarm_timer.start()

    def setup_ui(self):
        # --- Styles ---
        self.setStyleSheet("""
            QMainWindow { background-color: #f0f2f5; }
            QGroupBox { font-weight: bold; border: 1px solid #ccc; border-radius: 8px; margin-top: 10px; padding-top: 15px; background-color: white; }
            QGroupBox::title { subcontrol-origin: margin; subcontrol-position: top left; left: 10px; padding: 0 5px; }
            QLabel { color: #333; }
            QLineEdit { padding: 5px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9; }
            
            /* ë²„íŠ¼ ìŠ¤íƒ€ì¼ì„ íŠ¹ì • í´ë˜ìŠ¤ë¡œ ì œí•œí•˜ê±°ë‚˜ QMessageBox ë²„íŠ¼ì„ ìœ„í•œ ì˜ˆì™¸ ì²˜ë¦¬ */
            QPushButton { padding: 8px 15px; border-radius: 5px; font-weight: bold; color: white; border: none; }
            QPushButton:hover { opacity: 0.9; }
            
            /* QMessageBox ë²„íŠ¼ ë³µêµ¬ */
            QMessageBox QPushButton {
                background-color: #007bff; /* íŒŒë€ìƒ‰ */
                color: white;
                border: 1px solid #0056b3;
                min-width: 60px;
            }
            QMessageBox QPushButton:hover {
                background-color: #0056b3;
            }
            
            QTextEdit { background-color: #1e1e1e; color: #00ff00; font-family: 'Consolas', 'Monospace'; border-radius: 5px; padding: 10px; }
        """)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        # Root Layout: Vertical (Header + Body)
        root_layout = QVBoxLayout(central_widget)
        root_layout.setContentsMargins(10, 10, 10, 10)
        root_layout.setSpacing(10)

        # === 0. Global Header ===
        header_widget = QWidget()
        header_layout = QHBoxLayout(header_widget)
        header_layout.setContentsMargins(0, 0, 0, 10)
        
        # Spacer to balance
        left_spacer = QWidget()
        left_spacer.setFixedWidth(40) 
        
        title_label = QLabel("ğŸš€ KipoStock V3.7 (Alarm)")
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_label.setFont(QFont("Arial", 20, QFont.Weight.Bold))
        title_label.setStyleSheet("color: #2c3e50;")
        
        # Always on Top Button (Pin icon)
        self.btn_top = QPushButton("ğŸ“Œ")
        self.btn_top.setCheckable(True)
        self.btn_top.setFixedSize(40, 40)
        self.btn_top.setToolTip("í•­ìƒ ìœ„ì— ê³ ì •")
        self.btn_top.setStyleSheet("""
            QPushButton { background-color: #f8f9fa; border-radius: 5px; font-size: 18px; border: 1px solid #ddd; color: #aaa; }
            QPushButton:checked { background-color: #17a2b8; color: white; border: 1px solid #138496; }
            QPushButton:hover { background-color: #e2e6ea; }
        """)
        self.btn_top.clicked.connect(self.toggle_always_on_top)
        
        header_layout.addWidget(left_spacer)
        header_layout.addStretch()
        header_layout.addWidget(title_label)
        header_layout.addStretch()
        header_layout.addWidget(self.btn_top)
        
        root_layout.addWidget(header_widget)

        # === Body Layout (Left + Right) ===
        body_layout = QHBoxLayout()
        body_layout.setContentsMargins(0, 0, 0, 0)
        body_layout.setSpacing(10)
        root_layout.addLayout(body_layout)

        # === Left Panel: Settings ===
        left_panel = QFrame()
        left_panel.setFixedWidth(280)
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(0, 0, 0, 0)
        
        # 1. Settings Group
        settings_group = QGroupBox("âš™ï¸ Settings")
        settings_layout = QVBoxLayout()
        settings_layout.setSpacing(12)

        # Condition Select (0-9)
        cond_label = QLabel("ì¡°ê±´ì‹ ì„ íƒ (0-9)")
        self.cond_btn_layout = QHBoxLayout()
        self.cond_buttons = []
        for i in range(10):
            btn = QPushButton(str(i))
            btn.setFixedSize(22, 22)
            btn.setCheckable(True)
            btn.setStyleSheet("""
                QPushButton { background-color: #e0e0e0; color: #333; padding: 0; font-size: 10px; }
                QPushButton:checked { background-color: #007bff; color: white; }
            """)
            btn.clicked.connect(lambda checked, idx=i: self.on_cond_clicked(idx))
            self.cond_buttons.append(btn)
            self.cond_btn_layout.addWidget(btn)
        
        settings_layout.addWidget(cond_label)
        settings_layout.addLayout(self.cond_btn_layout)

        # Profit & Loss (Horizontal)
        pl_layout = QHBoxLayout()
        
        # Profit
        pl_layout.addWidget(QLabel("ìµì ˆ"))
        self.input_profit = QLineEdit()
        self.input_profit.setFixedWidth(60)
        pl_layout.addWidget(self.input_profit)
        
        pl_layout.addSpacing(10)
        
        # Loss
        pl_layout.addWidget(QLabel("ì†ì ˆ"))
        self.input_loss = QLineEdit()
        self.input_loss.setFixedWidth(60)
        pl_layout.addWidget(self.input_loss)
        
        pl_layout.addStretch() # Push to left
        settings_layout.addLayout(pl_layout)

        # Max Stocks
        settings_layout.addWidget(QLabel("ìµœëŒ€ ë³´ìœ  ì¢…ëª© ìˆ˜"))
        self.input_max = QLineEdit()
        settings_layout.addWidget(self.input_max)

        # Time Settings (Horizontal)
        time_layout = QHBoxLayout()
        
        # Start
        time_layout.addWidget(QLabel("ì‹œì‘"))
        self.input_start_time = QLineEdit()
        self.input_start_time.setFixedWidth(60)
        self.input_start_time.setAlignment(Qt.AlignmentFlag.AlignCenter)
        time_layout.addWidget(self.input_start_time)
        
        time_layout.addSpacing(10)
        
        # End
        time_layout.addWidget(QLabel("ì¢…ë£Œ"))
        self.input_end_time = QLineEdit()
        self.input_end_time.setFixedWidth(60)
        self.input_end_time.setAlignment(Qt.AlignmentFlag.AlignCenter)
        time_layout.addWidget(self.input_end_time)
        
        time_layout.addWidget(self.input_end_time)
        
        # ğŸ”” ì•ŒëŒ í•´ì œ ë²„íŠ¼
        self.btn_alarm_stop = QPushButton("ğŸ”•")
        self.btn_alarm_stop.setToolTip("ì•ŒëŒ í•´ì œ")
        self.btn_alarm_stop.setStyleSheet("""
            QPushButton {
                background-color: #dc3545; 
                color: white; 
                font-weight: bold;
                border: none;
                border-radius: 4px;
                padding: 4px 8px;
                font-size: 16px;
            }
            QPushButton:disabled {
                background-color: #e2e6ea;
                color: #adb5bd;
            }
        """)
        self.btn_alarm_stop.setFixedWidth(50)
        self.btn_alarm_stop.clicked.connect(self.stop_alarm)
        self.btn_alarm_stop.setEnabled(False) # ê¸°ë³¸ì€ ë¹„í™œì„±í™”
        self.btn_alarm_stop.setVisible(True)
        time_layout.addWidget(self.btn_alarm_stop)
        
        time_layout.addStretch()
        settings_layout.addLayout(time_layout)

        # ğŸ’ Global Buy Strategy Group
        strategy_group = QGroupBox("ğŸ’ ë§¤ìˆ˜ ì „ëµ (Buying Strategy)")
        strategy_group.setStyleSheet("""
            QGroupBox { 
                background-color: #ffffff; 
                border: 2px solid #007bff; 
                border-radius: 8px; 
                margin-top: 15px; 
                font-weight: bold;
                color: #007bff;
            }
        """)
        strat_layout = QVBoxLayout()
        strat_layout.setSpacing(10)

        # 1. Mode Selection (Radio)
        mode_layout = QHBoxLayout()
        self.rb_qty = QRadioButton("1ì£¼")
        self.rb_amount = QRadioButton("ê¸ˆì•¡")
        self.rb_percent = QRadioButton("ë¹„ìœ¨")
        
        self.bg_mode = QButtonGroup()
        self.bg_mode.addButton(self.rb_qty)
        self.bg_mode.addButton(self.rb_amount)
        self.bg_mode.addButton(self.rb_percent)
        
        # Default
        self.rb_qty.setChecked(True) 
        
        # Style
        for rb in [self.rb_qty, self.rb_amount, self.rb_percent]:
            rb.setStyleSheet("font-weight: bold; color: #333;")

        mode_layout.addWidget(self.rb_qty)
        mode_layout.addWidget(self.rb_amount)
        mode_layout.addWidget(self.rb_percent)
        strat_layout.addLayout(mode_layout)
        
        # 2. Value Input
        input_layout = QHBoxLayout()
        input_layout.addWidget(QLabel("ì„¤ì •ê°’:"))
        self.input_strategy_value = QLineEdit("1")
        self.input_strategy_value.setStyleSheet("""
            QLineEdit { 
                padding: 8px; 
                font-size: 14px; 
                border: 2px solid #ddd; 
                border-radius: 6px; 
                background-color: #f0f8ff;
                font-weight: bold;
                color: #000;
            }
            QLineEdit:focus { border: 2px solid #007bff; }
            QLineEdit:disabled { background-color: #e9ecef; color: #6c757d; }
        """)
        self.input_strategy_value.setAlignment(Qt.AlignmentFlag.AlignCenter)
        input_layout.addWidget(self.input_strategy_value)
        
        # Unit Label (ì£¼/ì›/%)
        self.lbl_unit = QLabel("ì£¼")
        self.lbl_unit.setStyleSheet("font-weight: bold; font-size: 14px; margin-left: 5px;")
        input_layout.addWidget(self.lbl_unit)
        
        strat_layout.addLayout(input_layout)
        
        # Helper text Removed
        
        # Event connections for UI feedback
        # Use lambda to differentiate user clicks vs programmatic changes if needed, but simple connect is fine here
        self.rb_qty.clicked.connect(lambda: self.update_strategy_ui(True)) 
        self.rb_amount.clicked.connect(lambda: self.update_strategy_ui(True))
        self.rb_percent.clicked.connect(lambda: self.update_strategy_ui(True))
        
        # Input Text Changed for Comma Formatting
        self.input_strategy_value.textEdited.connect(self.format_input_value)

        strategy_group.setLayout(strat_layout)
        settings_layout.addWidget(strategy_group)

        # Save Button
        btn_save = QPushButton("ğŸ’¾ ì„¤ì • ì €ì¥")
        btn_save.setStyleSheet("background-color: #6c757d; margin-top: 10px;")
        btn_save.clicked.connect(self.save_settings)
        settings_layout.addWidget(btn_save)
        
        settings_group.setLayout(settings_layout)
        left_layout.addWidget(settings_group)

        # 2. Real-time List
        rt_group = QGroupBox("ğŸ“‹ ì‹¤ì‹œê°„ ì¡°ê±´ì‹")
        rt_layout = QVBoxLayout()
        self.rt_list = QTextEdit()
        self.rt_list.setReadOnly(True)
        self.rt_list.setStyleSheet("background-color: white; color: black; border: 1px solid #ddd;")
        rt_layout.addWidget(self.rt_list)
        
        # ëª©ë¡ ê°±ì‹  ë²„íŠ¼ ì‚­ì œ (ì„¤ì • ì €ì¥ ì‹œ ìë™ ì‹¤í–‰)
        # btn_refresh = QPushButton("ğŸ”„ ëª©ë¡ ê°±ì‹ ")
        # btn_refresh.setStyleSheet("background-color: #fff; color: #333; border: 1px solid #ccc;")
        # btn_refresh.clicked.connect(lambda: self.worker.schedule_command('condition_list'))
        # rt_layout.addWidget(btn_refresh)
        
        rt_group.setLayout(rt_layout)
        left_layout.addWidget(rt_group)

        # === Right Panel: Controls & Logs ===

        right_panel = QFrame()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)

        # Header Layout Removed (Moved to Global)

        # Control Buttons
        btn_layout = QHBoxLayout()
        
        self.btn_start = QPushButton("â–¶ START")
        self.btn_start.setStyleSheet("background-color: #28a745; height: 35px; font-size: 14px;")
        self.btn_start.clicked.connect(lambda: self.worker.schedule_command('start'))
        
        self.btn_stop = QPushButton("â¹ STOP")
        self.btn_stop.setStyleSheet("background-color: #dc3545; height: 35px; font-size: 14px;")
        self.btn_stop.clicked.connect(lambda: self.worker.schedule_command('stop'))
        
        self.btn_report = QPushButton("ğŸ“Š REPORT")
        self.btn_report.setStyleSheet("background-color: #17a2b8; height: 35px; font-size: 14px;")
        self.btn_report.clicked.connect(lambda: self.worker.schedule_command('report'))

        btn_layout.addWidget(self.btn_start)
        btn_layout.addWidget(self.btn_stop)
        btn_layout.addWidget(self.btn_report)
        right_layout.addLayout(btn_layout)

        # System Log
        log_group = QGroupBox("ğŸ“„ System Logs")
        log_layout = QVBoxLayout()
        self.log_text = QTextEdit()
        self.log_text.setReadOnly(True)
        log_layout.addWidget(self.log_text)
        log_group.setLayout(log_layout)
        right_layout.addWidget(log_group)

        # Command Input
        input_layout = QHBoxLayout()
        input_label = QLabel("ëª…ë ¹ì–´ ì…ë ¥:")
        self.cmd_input = QLineEdit()
        self.cmd_input.returnPressed.connect(self.send_command)
        
        btn_send = QPushButton("ì „ì†¡")
        btn_send.setStyleSheet("background-color: #fff; color: #333; border: 1px solid #ccc;")
        btn_send.clicked.connect(self.send_command)

        input_layout.addWidget(input_label)
        input_layout.addWidget(self.cmd_input)
        input_layout.addWidget(btn_send)
        right_layout.addLayout(input_layout)

        # Add panels to body layout
        body_layout.addWidget(left_panel)
        body_layout.addWidget(right_panel)
        body_layout.setStretch(1, 1) # Right panel takes remaining space

    def setup_worker(self):
        self.worker = AsyncWorker(self)
        self.worker.signals.log_signal.connect(self.append_log)
        self.worker.start()

    def append_log(self, text):
        timestamp = datetime.datetime.now().strftime("%H:%M:%S")
        self.log_text.append(f"[{timestamp}] {text}")
        
        # ì¡°ê±´ì‹ ëª©ë¡ì´ë©´ ì™¼ìª½ íŒ¨ë„ì—ëŠ” **ì„ íƒëœ ì¡°ê±´ì‹ë§Œ** í•„í„°ë§í•˜ì—¬ í‘œì‹œ
        if "ğŸ“‹ [ì¡°ê±´ì‹ ëª©ë¡]" in text:
            filtered_msg = ""
            lines = text.split('\n')
            
            # í˜„ì¬ UIì—ì„œ ì²´í¬ëœ ë²ˆí˜¸ë“¤ ê°€ì ¸ì˜¤ê¸°
            checked_indices = [str(i) for i, btn in enumerate(self.cond_buttons) if btn.isChecked()]
            
            found_any = False
            for line in lines:
                if line.startswith('â€¢'):
                    # í¬ë§·: "â€¢ 0: ì¡°ê±´ì‹ì´ë¦„" -> ":" ê¸°ì¤€ìœ¼ë¡œ ë¶„ë¦¬
                    try:
                        parts = line.split(':')
                        idx = parts[0].replace('â€¢', '').strip()
                        
                        if idx in checked_indices:
                            filtered_msg += line + "\n"
                            found_any = True
                    except:
                        pass
            
            if not found_any:
                filtered_msg += "(ì„ íƒëœ ì¡°ê±´ì‹ì´ ëª©ë¡ì— ì—†ìŠµë‹ˆë‹¤)"
                
            self.rt_list.setText(filtered_msg)
            
        # Auto scroll
        sb = self.log_text.verticalScrollBar()
        sb.setValue(sb.maximum())


    def send_command(self):
        cmd = self.cmd_input.text().strip()
        if cmd:
            if cmd.upper() == 'PRINT':
                self.export_log()
            else:
                self.worker.schedule_command('custom', cmd)
            self.cmd_input.clear()

    def export_log(self):
        try:
            now_str = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"KIPOSTOCK_LOG_{now_str}.txt"
            
            # í˜„ì¬ ì‹¤í–‰ íŒŒì¼ ìœ„ì¹˜ì— ì €ì¥
            log_path = os.path.join(self.script_dir, filename)
            
            content = self.log_text.toPlainText()
            
            with open(log_path, 'w', encoding='utf-8') as f:
                f.write(content)
                
            self.append_log(f"ğŸ’¾ ë¡œê·¸ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤: {filename}")
            
            # ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼ (ì„ íƒ ì‚¬í•­)
            # QMessageBox.information(self, "ë¡œê·¸ ì €ì¥", f"ë¡œê·¸ê°€ íŒŒì¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.\n{filename}")
            
        except Exception as e:
            self.append_log(f"âŒ ë¡œê·¸ ì €ì¥ ì‹¤íŒ¨: {e}")

    def on_cond_clicked(self, idx):
        # ë‹¨ìˆœíˆ UI ìƒíƒœë§Œ ë³€ê²½ (ì„¤ì • ì €ì¥ ì‹œ ë°˜ì˜)
        pass

    # --- ì•ŒëŒ ë¡œì§ ---
    def check_alarm(self):
        # ì´ë¯¸ ìš¸ë¦¬ê³  ìˆìœ¼ë©´ íŒ¨ìŠ¤
        if self.alarm_playing:
            return

        # í”„ë¡œê·¸ë¨ ì‹œì‘ í›„ 5ì´ˆê°„ì€ ì•ŒëŒ ì²´í¬ ìŠ¤í‚µ (ì´ˆê¸°í™” ì•ˆì •í™” ëŒ€ê¸°)
        if (datetime.datetime.now() - self.app_start_time).total_seconds() < 5:
            return

        current_time = datetime.datetime.now().strftime("%H:%M")
        end_time_str = self.input_end_time.text().strip()
        
        # ì‹œê°„ì´ ì¼ì¹˜í•˜ê³ , ë°©ê¸ˆ ëˆ ì‹œê°„ì´ ì•„ë‹ˆë¼ë©´ ìš¸ë¦¼
        if current_time == end_time_str:
            if self.last_alarm_time != current_time:
                self.start_alarm()

    def start_alarm(self):
        if self.alarm_playing:
            return
            
        try:
            self.alarm_playing = True
            
            # ë²„íŠ¼ ìƒíƒœ ë³€ê²½ (ê°€ì¥ ì•ˆì „í•œ ë°©ì‹)
            self.btn_alarm_stop.setEnabled(True)
            self.btn_alarm_stop.setText("ğŸ””") # ì•„ì´ì½˜ ëŒ€ì‹  í…ìŠ¤íŠ¸ë¡œ í…ŒìŠ¤íŠ¸
            
            log_msg = f"â° ì•ŒëŒ ë°œìƒ: ì¢…ë£Œ ì‹œê°„({self.input_end_time.text()}) ë„ë‹¬!"
            self.append_log(log_msg)
            print(log_msg)
            
        except Exception as e:
            print(f"âš ï¸ ì•ŒëŒ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {e}")
            self.alarm_playing = False 

    # def play_subprocess_sound(self):  <-- ë©”ì„œë“œ ì œê±°
    #     pass

    def stop_alarm(self):
        if self.alarm_playing:
            # self.sound_repeater.stop()
            self.alarm_playing = False
            self.last_alarm_time = datetime.datetime.now().strftime("%H:%M") # í˜„ì¬ ë¶„ì—ëŠ” ë‹¤ì‹œ ì•ˆ ìš¸ë¦¼
            
            self.btn_alarm_stop.setEnabled(False)
            self.btn_alarm_stop.setStyleSheet("""
                QPushButton {
                    background-color: #dc3545; 
                    color: white; 
                    font-weight: bold;
                    border: none;
                    border-radius: 4px;
                    padding: 4px 8px;
                    font-size: 16px;
                }
                QPushButton:disabled {
                    background-color: #e2e6ea;
                    color: #adb5bd;
                }
            """)
            self.append_log("ğŸ”• ì•ŒëŒì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.")

    def update_strategy_ui(self, from_user_click=False):
        if self.rb_qty.isChecked():
            self.lbl_unit.setText("ì£¼")
            self.input_strategy_value.setText("1")
            self.input_strategy_value.setEnabled(False) # Disable input
            
        elif self.rb_amount.isChecked():
            self.lbl_unit.setText("ì›")
            self.input_strategy_value.setEnabled(True)
            self.input_strategy_value.setPlaceholderText("ì˜ˆ: 100,000")
            if from_user_click:
                 self.input_strategy_value.setText("100,000") # Default

        elif self.rb_percent.isChecked():
            self.lbl_unit.setText("%")
            self.input_strategy_value.setEnabled(True)
            self.input_strategy_value.setPlaceholderText("ì˜ˆ: 10")
            if from_user_click:
                 self.input_strategy_value.setText("10") # Default
                 
    def format_input_value(self, text):
        if self.rb_amount.isChecked():
            # Remove existing commas
            plain_text = text.replace(',', '')
            if plain_text.isdigit():
                formatted = f"{int(plain_text):,}"
                self.input_strategy_value.setText(formatted)
        else:
            # For percent/qty, no formatting needed usually, maybe float check?
            pass

    def load_settings_to_ui(self):
        try:
            with open(self.settings_file, 'r', encoding='utf-8') as f:
                settings = json.load(f)
            
            self.input_profit.setText(str(settings.get('take_profit_rate', '12.0')))
            self.input_loss.setText(str(settings.get('stop_loss_rate', '-1.2')))
            self.input_max.setText(str(settings.get('max_stocks', '20')))
            
            # Condition Button Set - Support Multiple Selection
            seq_data = settings.get('search_seq', [])
            
            # [ìˆ˜ì •] Robust parsing for search_seq
            if isinstance(seq_data, str):
                try:
                    # If it's a string representation of a list like "['0', '1']"
                    parsed = ast.literal_eval(seq_data)
                    if isinstance(parsed, list):
                        seq_data = parsed
                    else:
                        seq_data = [seq_data]
                except:
                    # Not a list-string, just a regular string
                    seq_data = [seq_data]
            elif isinstance(seq_data, int):
                seq_data = [str(seq_data)]
                
            # Convert to set of strings for easy lookup
            seq_set = set(map(str, seq_data))
            
            for i, btn in enumerate(self.cond_buttons):
                if str(i) in seq_set:
                    btn.setChecked(True)
                else:
                    btn.setChecked(False)
            
            # Times (if exist in settings, else default)
            self.input_start_time.setText(settings.get('start_time', '09:00'))
            self.input_end_time.setText(settings.get('end_time', '15:20'))
            
            # Special Buy Settings -> Global Strategy Settings
            mode = settings.get('global_strategy_mode', 'qty')
            val = settings.get('global_strategy_value', '1')
            scope = settings.get('global_strategy_scope', 'all')
            
            if mode == 'amount':
                self.rb_amount.setChecked(True)
            elif mode == 'percent':
                self.rb_percent.setChecked(True)
            else:
                self.rb_qty.setChecked(True)
                
            self.input_strategy_value.setText(str(val))
            
            # Legacy values check (if user saves new settings those will override)
            if mode == 'qty':
                 self.rb_qty.setChecked(True)
            elif mode == 'amount':
                 self.rb_amount.setChecked(True)
                 # Format saved value with comma
                 try:
                     val = f"{int(str(val).replace(',', '')):,}"
                 except: pass
            elif mode == 'percent':
                 self.rb_percent.setChecked(True)
                 
            self.input_strategy_value.setText(str(val))
            self.update_strategy_ui(False) # Update state but don't reset defaults
            
        except Exception as e:
            self.append_log(f"ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: {e}")

    def save_settings(self):
        try:
            # UI ê°’ ì½ê¸°
            tpr = self.input_profit.text()
            slr = self.input_loss.text()
            max_s = self.input_max.text()
            st = self.input_start_time.text()
            et = self.input_end_time.text()
            
            # ì¡°ê±´ì‹ ì„ íƒ ìƒíƒœ ì½ê¸° (ì¤‘ìš”: selected_seq ë³€ìˆ˜ ìƒì„±)
            selected_seq = []
            for i, btn in enumerate(self.cond_buttons):
                if btn.isChecked():
                    selected_seq.append(str(i))

            # Global Strategy Settings
            st_mode = 'qty'
            if self.rb_amount.isChecked(): st_mode = 'amount'
            elif self.rb_percent.isChecked(): st_mode = 'percent'
            
            st_val = self.input_strategy_value.text()
            # Scope is now ALWAYS 'all'
            st_scope = 'all'
            
            self.worker.schedule_command('update_setting', 'global_strategy_mode', st_mode)
            self.worker.schedule_command('update_setting', 'global_strategy_value', st_val)
            self.worker.schedule_command('update_setting', 'global_strategy_scope', st_scope)
            
            # Workerë¥¼ í†µí•´ ì—…ë°ì´íŠ¸
            self.worker.schedule_command('update_setting', 'take_profit_rate', float(tpr))
            self.worker.schedule_command('update_setting', 'stop_loss_rate', float(slr))
            self.worker.schedule_command('update_setting', 'max_stocks', int(max_s))
            self.worker.schedule_command('update_setting', 'start_time', st)
            self.worker.schedule_command('update_setting', 'end_time', et)
            
            # Legacy cleanup (optional but good practice to clear old keys or just ignore them)
            # For now, we just overwrite the new keys.
            
            # ì¡°ê±´ì‹ ë¦¬ìŠ¤íŠ¸ ì €ì¥
            self.worker.schedule_command('update_setting', 'search_seq', selected_seq)
            
            # ì‹œê°„ ì„¤ì • ì¦‰ì‹œ ë°˜ì˜
            sh, sm = map(int, st.split(':'))
            eh, em = map(int, et.split(':'))
            MarketHour.set_market_hours(sh, sm, eh, em)
            
            # ëª©ë¡ ê°±ì‹  ìë™ ì‹¤í–‰
            self.worker.schedule_command('condition_list')
            
            # [ì‹ ê·œ] ì €ì¥ ì‹œ ìºì‹œ ì´ˆê¸°í™” (ì¦‰ì‹œ ë°˜ì˜ ìœ„í•¨)
            if hasattr(cached_setting, "_cache"):
                cached_setting._cache = {}
                print("ğŸ§¹ ì„¤ì • ìºì‹œ ì´ˆê¸°í™” ì™„ë£Œ")
            
            QMessageBox.information(self, "ì €ì¥ ì™„ë£Œ", "ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.\nì‹¤ì‹œê°„ ì¡°ê±´ì‹ ëª©ë¡ë„ ê°±ì‹ ë©ë‹ˆë‹¤.")
            
        except ValueError:
            QMessageBox.warning(self, "ì…ë ¥ ì˜¤ë¥˜", "ìˆ«ì í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.")
        except Exception as e:
             QMessageBox.critical(self, "ì˜¤ë¥˜", f"ì €ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")

    def toggle_always_on_top(self, checked):
        if checked:
            self.setWindowFlag(Qt.WindowType.WindowStaysOnTopHint, True)
            self.show()
        else:
            self.setWindowFlag(Qt.WindowType.WindowStaysOnTopHint, False)
            self.show()

    def closeEvent(self, event):
        reply = QMessageBox.question(self, 'ì¢…ë£Œ', 'í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?',
                                   QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, 
                                   QMessageBox.StandardButton.No)

        if reply == QMessageBox.StandardButton.Yes:
            self.worker.stop()
            event.accept()
        else:
            event.ignore()

if __name__ == '__main__':
    try:
        app = QApplication(sys.argv)
        
        # Font Setup
        font = QFont("Malgun Gothic", 9)
        app.setFont(font)
        
        window = KipoWindow()
        window.show()
        
        retCode = app.exec()
        sys.exit(retCode)
        
    except BaseException as e:
        # BaseExceptionì„ í†µí•´ SystemExitê¹Œì§€ ëª¨ë‘ ìº¡ì²˜
        with open("crash_report.txt", "a", encoding="utf-8") as f:
            f.write(f"\n[{datetime.datetime.now()}] CRASH/EXIT LOGGED:\n")
            f.write(traceback.format_exc())
            f.write(f"Error Type: {type(e)}\n")
            f.write("-" * 50 + "\n")
        
        if not isinstance(e, SystemExit):
            print(f"CRITICAL ERROR (Logged to crash_report.txt): {e}")
            input("Press Enter to exit...")
```

## Verification Results

### Code Review
- The `AttributeError` caused by `self.last_alarm_time` missing is resolved by adding it to [__init__](file:///d:/Work/Python/AutoBuy/KipoBuy_Gui/Kipo_main.py#10-18).
- The `NameError` caused by `sound_file` being used in an orphaned `else` block is resolved by removing the block.
- The logic for [check_alarm](file:///d:/Work/Python/AutoBuy/KipoBuy_Gui/Kipo_GUI_main.py#624-640) now safely compares `self.last_alarm_time` without crashing.

> [!IMPORTANT]
> ë§Œì•½ .exe íŒŒì¼ì„ ì‹¤í–‰ ì¤‘ì´ì‹œë¼ë©´, ë³€ê²½ëœ ì½”ë“œë¥¼ ë°˜ì˜í•˜ê¸° ìœ„í•´ **ë‹¤ì‹œ ë¹Œë“œ(Build)**í•´ì•¼ í•©ë‹ˆë‹¤. 
> [build_exe.py](file:///d:/Work/Python/AutoBuy/KipoBuy_Gui/build_exe.py)ë¥¼ ì‹¤í–‰í•˜ì—¬ ìƒˆë¡œìš´ ì‹¤í–‰ íŒŒì¼ì„ ë§Œë“¤ì–´ ì£¼ì„¸ìš”.
