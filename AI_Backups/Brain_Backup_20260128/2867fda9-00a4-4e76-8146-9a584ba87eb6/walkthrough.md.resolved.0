# ì‹œí€€ìŠ¤ ìë™ ëª¨ë“œ ê°œì„  ì™„ë£Œ ë³´ê³ ì„œ

ì‚¬ìš©ì ìš”ì²­ì— ë”°ë¼ ì‹œí€€ìŠ¤ ìë™ ëª¨ë“œì˜ ì•ˆì •ì„±ì„ ë†’ì´ê³  ì§„í–‰ ìƒí™©ì„ ë” ëª…í™•í•˜ê²Œ í™•ì¸í•  ìˆ˜ ìˆë„ë¡ ë³´ì™„ ì‘ì—…ì„ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤.

## ì£¼ìš” ë³€ê²½ ì‚¬í•­

### 1. í”„ë¡œí•„ ì „í™˜ ë° ì¢…ë£Œ ë³´ê³  ëŒ€ê¸° ì‹œê°„ ì—°ì¥
ì´ì „ í”„ë¡œí•„ì˜ API ì„¸ì…˜ì´ ì™„ì „íˆ ì •ë¦¬ë  ì‹œê°„ì„ í™•ë³´í•˜ì—¬ ì¤‘ë³µ ë¡œê·¸ì¸ ì˜¤ë¥˜(R10001)ë¥¼ ë°©ì§€í–ˆìŠµë‹ˆë‹¤.
- **ìˆ˜ì • ì „**: 2.5ì´ˆ (2500ms)
- **ìˆ˜ì • í›„**: **5.0ì´ˆ (5000ms)**
- ì ìš© ìœ„ì¹˜: [handle_end_time_event](file:///d:/Work/Python/AutoBuy/KipoStockNow/Kipo_GUI_main.py#1482-1545) í•¨ìˆ˜ (í”„ë¡œí•„ ì „í™˜ ì‹œ ë° ìµœì¢… ì¢…ë£Œ ì‹œ)

### 2. ì‹œí€€ìŠ¤ ì‘ë™ ì˜ˆì•½ ëª©ë¡ ë¡œê·¸ ì¶œë ¥
'ì‹œí€€ìŠ¤ ìë™' ë²„íŠ¼ì„ ëˆ„ë¥¼ ë•Œ, í˜„ì¬ í”„ë¡œí•„ë¶€í„° ë§ˆì§€ë§‰ 3ë²ˆ í”„ë¡œí•„ê¹Œì§€ ì–´ë–¤ ì‹œê°„ëŒ€ì— ì–´ë–¤ ë§¤ë§¤ ì¡°ê±´ìœ¼ë¡œ ì‘ë™í• ì§€ ë¡œê·¸ì°½ì— ìƒì„¸íˆ ì¶œë ¥í•˜ë„ë¡ ê°œì„ í–ˆìŠµë‹ˆë‹¤.

**ë¡œê·¸ ì¶œë ¥ ì˜ˆì‹œ:**
```text
ğŸ”„ ì‹œí€€ìŠ¤ ìë™ ëª¨ë“œ ON: ì¢…ë£Œ ì‹œê°„ ë„ë‹¬ ì‹œ ë‹¤ìŒ í”„ë¡œí•„ë¡œ ì „í™˜í•©ë‹ˆë‹¤.
==================================================
ğŸ“‹ [ì‹œí€€ìŠ¤ ì‘ë™ ì˜ˆì•½ ëª©ë¡]
  - í”„ë¡œí•„ 1ë²ˆ: 09:00 ~ 10:30 (ì¡°ê±´ì‹ 5ê°œ ê°ì‹œ) [í˜„ì¬]
  - í”„ë¡œí•„ 2ë²ˆ: 10:30 ~ 13:00 (ì¡°ê±´ì‹ 8ê°œ ê°ì‹œ)
  - í”„ë¡œí•„ 3ë²ˆ: 13:00 ~ 15:20 (ì¡°ê±´ì‹ 3ê°œ ê°ì‹œ)
==================================================
```

## ê²€ì¦ ê²°ê³¼
- **ë²„íŠ¼ í† ê¸€ í…ŒìŠ¤íŠ¸**: ì‹œí€€ìŠ¤ ë²„íŠ¼ ì‘ë™ ì‹œ [settings.json](file:///d:/Work/Python/AutoBuy/KipoStockNow/settings.json)ì—ì„œ ë‹¤ìŒ í”„ë¡œí•„ ì •ë³´ë¥¼ ì •ìƒì ìœ¼ë¡œ ì½ì–´ì™€ ë¡œê·¸ì— í‘œì‹œí•¨ì„ í™•ì¸í–ˆìŠµë‹ˆë‹¤.
- **íƒ€ì´ë° í…ŒìŠ¤íŠ¸**: í”„ë¡œí•„ ì „í™˜ ì½”ë“œì—ì„œ `singleShot` ë”œë ˆì´ê°€ 5000msë¡œ ì •ìƒ ì—…ë°ì´íŠ¸ëœ ê²ƒì„ í™•ì¸í–ˆìŠµë‹ˆë‹¤.

```diff:Kipo_GUI_main.py


import sys
import os
import asyncio
import json
import datetime
import traceback
import ast
import requests
from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                           QHBoxLayout, QLabel, QLineEdit, QPushButton, 
                           QTextEdit, QFrame, QGridLayout, QMessageBox, QGroupBox,
                           QScrollArea, QRadioButton, QButtonGroup, QCheckBox)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QObject, QTimer
from PyQt6.QtGui import QFont, QIcon, QColor, QPalette
import winsound

# ê¸°ì¡´ ëª¨ë“ˆ ì„í¬íŠ¸

# ê¸°ì¡´ ëª¨ë“ˆ ì„í¬íŠ¸
from config import telegram_token
from chat_command import ChatCommand
from get_setting import get_setting, cached_setting
from market_hour import MarketHour

# ----------------- Worker Thread for Asyncio Loop -----------------
class WorkerSignals(QObject):
    log_signal = pyqtSignal(str)
    status_signal = pyqtSignal(str)  # ìƒíƒœ í‘œì‹œì¤„ ì—…ë°ì´íŠ¸ìš©
    clr_signal = pyqtSignal()       # [ì‹ ê·œ] ë¡œê·¸ ì´ˆê¸°í™”ìš©
    request_log_signal = pyqtSignal() # [ì‹ ê·œ] ë¡œê·¸ íŒŒì¼ ì¶œë ¥ ìš”ì²­

class AsyncWorker(QThread):
    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self.signals = WorkerSignals()
        self.loop = None
        self.chat_command = None
        self.keep_running = True
        self.pending_start = False # [ì¶”ê°€] ì¥ì™¸ ì‹œê°„ ì˜ˆì•½ ì‹œì‘ ê¸°ëŠ¥ìš©
        self.pending_profile_info = None

    def run(self):
        # Create a new event loop for this thread
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)
        
        # 1. Override tel_send logic
        import chat_command as chat_cmd_module
        
        def gui_log_send(text):
            self.signals.log_signal.emit(text)
        
        # Patch tel_send in chat_command
        chat_cmd_module.tel_send = gui_log_send
        
        # 2. Redirect stdout/stderr to capture prints from get_seq.py and others
        class StreamRedirector:
            def __init__(self, emitter):
                self.emitter = emitter
            def write(self, text):
                text = text.strip()
                if text:
                    self.emitter(text)
            def flush(self):
                pass
                
        sys.stdout = StreamRedirector(gui_log_send)
        sys.stderr = StreamRedirector(gui_log_send)

        # Initialize ChatCommand
        self.chat_command = ChatCommand()
        self.chat_command.on_clear_logs = lambda: self.signals.clr_signal.emit()
        self.chat_command.on_request_log_file = lambda: self.signals.request_log_signal.emit()
        self.chat_command.rt_search.on_connection_closed = self._on_connection_closed_wrapper
        
        self.loop.run_until_complete(self.main_loop())
        self.loop.close()

    async def _on_connection_closed_wrapper(self):
        self.signals.log_signal.emit("âš ï¸ ì—°ê²° ëŠê¹€ ê°ì§€. ì¬ì—°ê²° ì‹œë„ ì¤‘...")
        await self.chat_command._on_connection_closed()

    async def main_loop(self):
        self.signals.log_signal.emit("ğŸš€ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ. ëŒ€ê¸° ì¤‘...")
        
        # ì„¤ì • ë¡œë“œ ë° ì ìš©
        self.load_initial_settings()
        
        # ì‹œì‘ ì‹œ ìë™ìœ¼ë¡œ ì¡°ê±´ì‹ ëª©ë¡ ê°€ì ¸ì˜¤ê¸° (ë§ˆì§€ë§‰ ì €ì¥ëœ ì„¤ì •ëŒ€ë¡œ í•„í„°ë§ë˜ì–´ í‘œì‹œë¨)
        self.signals.log_signal.emit("â„¹ï¸ ì €ì¥ëœ ì¡°ê±´ì‹ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤...")
        await self.chat_command.condition()
        
        # [ì¶”ê°€] ìë™ ì‹œì‘(auto_start) ì„¤ì • í™•ì¸ ë° ì‹¤í–‰
        try:
            settings_path = os.path.join(os.path.dirname(sys.executable) if getattr(sys, 'frozen', False) else os.path.dirname(os.path.abspath(__file__)), 'settings.json')
            if os.path.exists(settings_path):
                with open(settings_path, 'r', encoding='utf-8') as f:
                    settings = json.load(f)
                
                if settings.get('auto_start', False):
                    self.signals.log_signal.emit("â„¹ï¸ ìë™ ì‹œì‘ ì„¤ì •ì´ í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.")
                    # ì•½ê°„ì˜ ë”œë ˆì´ í›„ ì‹œì‘ ì‹œë„ (ì´ˆê¸°í™” ì•ˆì •ì„± í™•ë³´)
                    await asyncio.sleep(1.0)
                    # ì§ì ‘ await í˜¸ì¶œ (ê°™ì€ ë£¨í”„ ë‚´ì´ë¯€ë¡œ schedule_command ëŒ€ì‹  ì§ì ‘ í˜¸ì¶œ)
                    await self._execute_command('start')
        except Exception as e:
            self.signals.log_signal.emit(f"âš ï¸ ìë™ ì‹œì‘ í™•ì¸ ì¤‘ ì˜¤ë¥˜: {e}")
        
        try:
            while self.keep_running:
                # í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ í™•ì¸ (GUIì—ì„œëŠ” í•„ìˆ˜ ì•„ë‹˜, í…”ë ˆê·¸ë¨ ì œì–´ ì›í•  ì‹œ ìœ ì§€)
                message = self.get_chat_updates()
                if message:
                    await self.chat_command.process_command(message)
                
                
                # [ì¶”ê°€] ì¥ ì¢…ë£Œ ì‹œ ìë™ ì¤‘ë‹¨ ë° ë³´ê³  ì‹œí€€ìŠ¤ (15:30)
                now = datetime.datetime.now()
                if now.hour == 15 and now.minute == 30 and not self.today_stopped:
                    self.today_stopped = True
                    self.signals.log_signal.emit("ğŸ”” ì¥ ì¢…ë£Œ ì‹œê°„(15:30)ì´ ë˜ì–´ ìë™ìœ¼ë¡œ ì •ì‚° ì‹œí€€ìŠ¤ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.")
                    
                    # 1. ì¤‘ì§€ (STOP)
                    await self.chat_command.stop(set_auto_start_false=False)
                    # 2. ë‹¹ì¼ ì¼ì§€ (TODAY)
                    await self.chat_command.today()
                    # 3. ê³„ì¢Œ ë³´ê³  (REPORT)
                    await self.chat_command.report()

                # ë‚ ì§œê°€ ë°”ë€Œë©´ ì¢…ë£Œ í”Œë˜ê·¸ ì´ˆê¸°í™”
                current_date = now.date()
                if self.last_check_date != current_date:
                    self.last_check_date = current_date
                    self.today_stopped = False

                # ì¥ ì‹œì‘/ì¢…ë£Œ ì‹œê°„ ìë™ í™•ì¸ ë¡œì§
                # [ìˆ˜ì •] ëŒ€ê¸° ì‹œê°„(is_waiting_period)ì´ ì•„ë‹ ë•Œë§Œ ìë™ ì‹œì‘ ì§„í–‰í•˜ì—¬ ë¬´í•œ ë£¨í”„ ë°©ì§€
                if self.pending_start and MarketHour.is_market_open_time() and not MarketHour.is_waiting_period():
                    self.pending_start = False
                    self.signals.log_signal.emit("ğŸ”” ì¥ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. ê°ì‹œë¥¼ ìë™ìœ¼ë¡œ ì‹œì‘í•©ë‹ˆë‹¤!")
                    self.schedule_command('start', getattr(self, 'pending_profile_info', None))
                
                await asyncio.sleep(1.0) # ì²´í¬ ì£¼ê¸° ì¡°ì •
                
        except Exception as e:
            self.signals.log_signal.emit(f"âŒ ë©”ì¸ ë£¨í”„ ì—ëŸ¬: {e}")

    def load_initial_settings(self):
        try:
            with open('settings.json', 'r', encoding='utf-8') as f:
                settings = json.load(f)
                
            # ì‹œê°„ ì„¤ì • ì ìš© (settings.jsonì— ì‹œê°„ì´ ì—†ë‹¤ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©)
            start_time = settings.get('start_time', "09:00")
            end_time = settings.get('end_time', "15:20") # ì¥ ì¢…ë£Œ 10ë¶„ì „
            
            sh, sm = map(int, start_time.split(':'))
            eh, em = map(int, end_time.split(':'))
            
            MarketHour.set_market_hours(sh, sm, eh, em)
            self.signals.log_signal.emit(f"âš™ï¸ ì¥ ìš´ì˜ ì‹œê°„ ì„¤ì •: {start_time} ~ {end_time}")
            
        except Exception as e:
            self.signals.log_signal.emit(f"âš ï¸ ì„¤ì • ë¡œë“œ ì¤‘ ì˜¤ë¥˜ (ê¸°ë³¸ê°’ ì‚¬ìš©): {e}")

    # MainAppì˜ ë¡œì§ ê°€ì ¸ì˜´
    last_update_id = 0
    telegram_url = f"https://api.telegram.org/bot{telegram_token}/getUpdates"
    today_started = False
    today_stopped = False
    last_check_date = None

    def get_chat_updates(self):
        """í…”ë ˆê·¸ë¨ì—ì„œ ìƒˆë¡œìš´ ëª…ë ¹ì–´ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤."""
        try:
            params = {'offset': self.last_update_id + 1, 'timeout': 1}
            response = requests.get(self.telegram_url, params=params, timeout=5)
            if response.status_code == 200:
                data = response.json()
                for update in data.get('result', []):
                    self.last_update_id = update['update_id']
                    if 'message' in update and 'text' in update['message']:
                        chat_id = str(update['message']['chat']['id'])
                        
                        # [ë³´ì•ˆ] ì„¤ì •ëœ chat_idì™€ ì¼ì¹˜í•  ë•Œë§Œ ì‹¤í–‰
                        from config import telegram_chat_id
                        if chat_id == telegram_chat_id:
                            return update['message']['text']
                        else:
                            print(f"âš ï¸ ê¶Œí•œ ì—†ëŠ” ì‚¬ìš©ì ì ‘ê·¼ ì°¨ë‹¨ (ID: {chat_id})")
        except Exception as e:
            # Polling ì—ëŸ¬ëŠ” ë¡œê·¸ì—ë§Œ ê°„ë‹¨íˆ ê¸°ë¡
            pass
        return None
            
    # check_market_timing ë©”ì„œë“œ ì œê±° (ìë™ ì¢…ë£Œ ì¶©ëŒ ë°©ì§€)

    # GUIì—ì„œ í˜¸ì¶œí•  ë¹„ë™ê¸° ëª…ë ¹ë“¤
    def schedule_command(self, cmd_type, *args):
        asyncio.run_coroutine_threadsafe(self._execute_command(cmd_type, *args), self.loop)

    async def _execute_command(self, cmd_type, *args):
        try:
            if cmd_type == 'start':
                # [ìˆ˜ì •] ì¥ì™¸ ì‹œê°„ ì˜ˆì•½ ì‹œì‘ ì²˜ë¦¬ (ì‚¬ìš©ì ìš”ì²­: 15:30 ~ 09:00 ì‚¬ì´ë§Œ WAITING ì²˜ë¦¬)
                # ë‚® ì‹œê°„(09~15:30) ì¤‘ì— ì‚¬ìš©ì ì¢…ë£Œ ì„¤ì • ë“±ìœ¼ë¡œ ì‹œì‘ì´ ì•ˆë˜ëŠ” ê²½ìš°ëŠ” READY ìœ ì§€
                if MarketHour.is_waiting_period():
                    if not self.pending_start:
                        self.pending_start = True
                        self.pending_profile_info = args[0] if args else None
                        
                        # [ìˆ˜ì •] ì•ˆë‚´ ë©”ì‹œì§€ì— ì‹¤ì œ ì„¤ì •ëœ ì‹œê°„ í‘œì‹œ (main_window ìœ„ì ¯ ì ‘ê·¼ ìˆ˜ì •)
                        st_str = self.main_window.input_start_time.text()
                        et_str = self.main_window.input_end_time.text()
                        self.signals.log_signal.emit(f"â³ í˜„ì¬ ì¥ì™¸ ëŒ€ê¸° ì‹œê°„ì…ë‹ˆë‹¤. ({st_str}~{et_str})")
                        self.signals.log_signal.emit("âŒ› ì¥ì´ ì‹œì‘ë˜ë©´ ìë™ìœ¼ë¡œ ê°ì‹œë¥¼ ê°œì‹œí•˜ê² ìŠµë‹ˆë‹¤.")
                        self.signals.status_signal.emit("WAITING")
                    return
                
                # ë‚® ì‹œê°„ì¸ë° ì‹œì‘ ì‹œë„
                profile_info = args[0] if args else None
                success = await self.chat_command.start(profile_info=profile_info)
                if success:
                    self.pending_start = False
                    self.signals.status_signal.emit("RUNNING")
                else:
                    self.signals.status_signal.emit("READY")
                    self.signals.log_signal.emit("âš ï¸ ì¥ ì‹œì‘ ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì‹œê°„ ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.")
                    # [ì‹ ê·œ] ì¥ì™¸ ì‹œê°„ ë“± ì‹œì‘ ì‹¤íŒ¨ ì‹œ ê²½ê³ ìŒ
                    try:
                        import winsound
                        winsound.MessageBeep(winsound.MB_ICONEXCLAMATION)
                    except: pass
                return
            elif cmd_type == 'stop':
                self.pending_start = False # ì˜ˆì•½ ì·¨ì†Œ
                await self.chat_command.stop(True)
                self.signals.status_signal.emit("READY")
            elif cmd_type == 'report':
                await self.chat_command.report()
            elif cmd_type == 'custom':
                await self.chat_command.process_command(args[0])
            elif cmd_type == 'update_setting':
                # settings.json ì—…ë°ì´íŠ¸
                self.chat_command.update_setting(args[0], args[1])
                self.signals.log_signal.emit(f"âœ… ì„¤ì • ë³€ê²½: {args[0]} = {args[1]}")
                
            elif cmd_type == 'update_settings':
                # [ì‹ ê·œ] ì—¬ëŸ¬ ì„¤ì •ì„ í•œ ë²ˆì— ì—…ë°ì´íŠ¸
                updates = args[0]
                quiet = args[1] if len(args) > 1 else False
                self.chat_command.update_settings_batch(updates)
                if not quiet:
                    self.signals.log_signal.emit("âœ… ì¼ê´„ ì„¤ì • ì €ì¥ ì™„ë£Œ")
                
            elif cmd_type == 'today':
                await self.chat_command.today()
                
            elif cmd_type == 'condition_list':
                quiet = args[0] if args else False
                await self.chat_command.condition(quiet=quiet) # quiet ì¸ì ì „ë‹¬

        except Exception as e:
            self.signals.log_signal.emit(f"âŒ ëª…ë ¹ ì‹¤í–‰ ì˜¤ë¥˜: {e}")

    def stop(self):
        """ì•ˆì „í•œ ì¢…ë£Œ ì²˜ë¦¬"""
        self.keep_running = False
        if self.loop and self.loop.is_running():
             # ë£¨í”„ ë‚´ì—ì„œ ì •ë¦¬ ì‘ì—… ìˆ˜í–‰ í›„ ì¢…ë£Œ
             self.loop.call_soon_threadsafe(lambda: asyncio.create_task(self.shutdown()))
        
        # ìŠ¤ë ˆë“œ ì¢…ë£Œ ëŒ€ê¸° (ìµœëŒ€ 3ì´ˆ)
        self.wait(3000)

    async def shutdown(self):
        """ë¹„ë™ê¸° ë¦¬ì†ŒìŠ¤ ì •ë¦¬"""
        if self.chat_command:
            await self.chat_command.stop(True)
        # ë£¨í”„ ì •ì§€ (pending task cancelì€ ìƒëµí•¨)
        self.loop.stop()


# ----------------- Main Window -----------------
class KipoWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("ğŸš€ KipoBuy Auto Trading System - V5.3.9 (Automation Edition)")
        # íŒŒì¼ ê²½ë¡œ ì„¤ì • (ì¤‘ìš”: ë¦¬ì†ŒìŠ¤ì™€ ì„¤ì • íŒŒì¼ ë¶„ë¦¬)
        if getattr(sys, 'frozen', False):
            # ì‹¤í–‰ íŒŒì¼ ìœ„ì¹˜ (settings.json, ë¡œê·¸ ì €ì¥ìš©)
            self.script_dir = os.path.dirname(sys.executable)
            # ì„ì‹œ ë¦¬ì†ŒìŠ¤ ìœ„ì¹˜ (ì•„ì´ì½˜ ë“± ë²ˆë“¤ëœ íŒŒì¼ìš©)
            self.resource_dir = sys._MEIPASS
        else:
            self.script_dir = os.path.dirname(os.path.abspath(__file__))
            self.resource_dir = self.script_dir
            
        self.settings_file = os.path.join(self.script_dir, 'settings.json')

        # ì•„ì´ì½˜ ì„¤ì • (ë¦¬ì†ŒìŠ¤ ê²½ë¡œì—ì„œ ë¡œë“œ)
        icon_path = os.path.join(self.resource_dir, 'icon.png')
        icon_path_ico = os.path.join(self.resource_dir, 'icon.ico')
        
        if os.path.exists(icon_path):
            self.setWindowIcon(QIcon(icon_path))
        elif os.path.exists(icon_path_ico):
            self.setWindowIcon(QIcon(icon_path_ico))
        else:
            # Fallback checks in script directory
            for ext in ['png', 'ico']:
                p = os.path.join(self.script_dir, f'icon.{ext}')
                if os.path.exists(p):
                    self.setWindowIcon(QIcon(p))
                    break
                
        self.resize(1000, 700)
        
        self.setup_ui()
        self.setup_worker()
        self.load_settings_to_ui()

        # ì•ŒëŒ ê´€ë ¨ ì´ˆê¸°í™”
        self.alarm_playing = False
        self.last_alarm_time = None # ì´ì „ ì•ŒëŒ ë°œìƒ ì‹œê°„ (ì¤‘ë³µ ë°œìƒ ë°©ì§€)
        self.app_start_time = datetime.datetime.now() # ì‹œì‘ ì‹œê°„ ê¸°ë¡ (ì•ˆì „ì¥ì¹˜)
        self.last_auto_start_time = None # [ì‹ ê·œ] ì‹œì‘ ì•ŒëŒ ì¤‘ë³µ ë°©ì§€ìš©

        # ì•ŒëŒ ë°˜ë³µ íƒ€ì´ë¨¸ ì œê±° (ì†Œë¦¬ ê¸°ëŠ¥ ì™„ì „ ë¹„í™œì„±í™”)
        # self.sound_repeater = QTimer(self)
        
        self.alarm_timer = QTimer(self)
        self.alarm_timer.setInterval(1000) # 1ì´ˆë§ˆë‹¤ ì²´í¬
        self.alarm_timer.timeout.connect(self.check_alarm)
        self.alarm_timer.start()

        # ì•ŒëŒ ë²„íŠ¼ ê¹œë¹¡ì„ íƒ€ì´ë¨¸
        self.blink_timer = QTimer(self)
        self.blink_timer.setInterval(500) # 0.5ì´ˆë§ˆë‹¤ ë°˜ì „
        self.blink_timer.timeout.connect(self.toggle_blink)
        self.is_blink_on = False

        # í”„ë¡œí•„ ê´€ë ¨ ì´ˆê¸°í™”
        self.is_save_mode = False
        self.profile_blink_timer = QTimer(self)
        self.profile_blink_timer.setInterval(400) # ì ë©¸ ì†ë„
        self.profile_blink_timer.timeout.connect(self.toggle_profile_blink)
        self.is_profile_blink_on = False
        self.current_profile_idx = None # í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ ì¸ë±ìŠ¤

    def setup_ui(self):
        # --- Styles ---
        self.setStyleSheet("""
            QMainWindow { background-color: #f0f2f5; }
            QGroupBox { font-weight: bold; border: 1px solid #ccc; border-radius: 8px; margin-top: 10px; padding-top: 15px; background-color: white; }
            QGroupBox::title { subcontrol-origin: margin; subcontrol-position: top left; left: 10px; padding: 0 5px; }
            QLabel { color: #333; }
            QLineEdit { padding: 5px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9; }
            
            /* ë²„íŠ¼ ìŠ¤íƒ€ì¼ì„ íŠ¹ì • í´ë˜ìŠ¤ë¡œ ì œí•œí•˜ê±°ë‚˜ QMessageBox ë²„íŠ¼ì„ ìœ„í•œ ì˜ˆì™¸ ì²˜ë¦¬ */
            QPushButton { padding: 8px 15px; border-radius: 5px; font-weight: bold; color: white; border: none; }
            QPushButton:hover { opacity: 0.9; }
            
            /* QMessageBox ë²„íŠ¼ ë³µêµ¬ */
            QMessageBox QPushButton {
                background-color: #007bff; /* íŒŒë€ìƒ‰ */
                color: white;
                border: 1px solid #0056b3;
                min-width: 60px;
            }
            QMessageBox QPushButton:hover {
                background-color: #0056b3;
            }
            
            QTextEdit { background-color: #1e1e1e; color: #00ff00; font-family: 'Consolas', 'Monospace'; border-radius: 5px; padding: 10px; }
        """)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        # Root Layout: Vertical (Header + Body)
        root_layout = QVBoxLayout(central_widget)
        root_layout.setContentsMargins(10, 10, 10, 10)
        root_layout.setSpacing(10)

        # === 0. Global Header ===
        header_widget = QWidget()
        header_layout = QHBoxLayout(header_widget)
        header_layout.setContentsMargins(0, 0, 0, 10)
        
        # Spacer to balance
        left_spacer = QWidget()
        left_spacer.setFixedWidth(40) 
        
        self.lbl_main_title = QLabel("ğŸš€ KipoStock V5.1 (Stable)")
        self.lbl_main_title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.lbl_main_title.setFont(QFont("Arial", 20, QFont.Weight.Bold))
        self.lbl_main_title.setStyleSheet("color: #2c3e50;")

        # [ì‹ ê·œ] ìƒíƒœ í‘œì‹œë“± (READY / RUNNING)
        self.lbl_status = QLabel("â— READY")
        self.lbl_status.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        self.lbl_status.setStyleSheet("color: #6c757d; margin-left: 10px;")

        # [ì‹ ê·œ] í˜„ì¬ ì‹œê°„ í‘œì‹œ ì‹œê³„
        self.lbl_clock = QLabel(datetime.datetime.now().strftime("%H:%M:%S"))
        self.lbl_clock.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        self.lbl_clock.setStyleSheet("color: #2c3e50; margin-left: 10px;")
        
        # Always on Top Button (Pin icon)
        self.btn_top = QPushButton("ğŸ“")
        self.btn_top.setCheckable(True)
        self.btn_top.setFixedSize(40, 40)
        self.btn_top.setToolTip("í•­ìƒ ìœ„ì— ê³ ì •")
        self.btn_top.setStyleSheet("""
            QPushButton { background-color: #f8f9fa; border-radius: 5px; font-size: 18px; border: 1px solid #ddd; color: #aaa; }
            QPushButton:checked { background-color: #17a2b8; color: white; border: 1px solid #138496; }
            QPushButton:hover { background-color: #e2e6ea; }
        """)
        self.btn_top.clicked.connect(self.toggle_always_on_top)
        
        header_layout.addWidget(left_spacer)
        header_layout.addStretch()
        header_layout.addWidget(self.lbl_main_title)
        header_layout.addWidget(self.lbl_status)
        header_layout.addWidget(self.lbl_clock)
        header_layout.addStretch()
        header_layout.addWidget(self.btn_top)
        
        root_layout.addWidget(header_widget)

        # === Body Layout (Left + Right) ===
        body_layout = QHBoxLayout()
        body_layout.setContentsMargins(0, 0, 0, 0)
        body_layout.setSpacing(10)
        root_layout.addLayout(body_layout)

        # === Left Panel: Settings ===
        left_panel = QFrame()
        left_panel.setFixedWidth(280)
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(0, 0, 0, 0)
        
        # 1. Settings Group
        settings_group = QGroupBox("âš™ï¸ Settings")
        settings_layout = QVBoxLayout()
        settings_layout.setSpacing(12)

        # Condition Select (0-19) - 4 State Buttons
        cond_label = QLabel("ì¡°ê±´ì‹ ì„ íƒ (0-19)")
        self.cond_btn_layout = QGridLayout() # [ìˆ˜ì •] Grid Layout ì‚¬ìš©
        self.cond_btn_layout.setSpacing(2)
        self.cond_buttons = []
        # State: 0 (Gray/Off), 1 (Red/Qty), 2 (Green/Amt), 3 (Blue/Pct)
        self.cond_states = [0] * 20 # [ìˆ˜ì •] 20ê°œë¡œ í™•ì¥
        
        for i in range(20):
            btn = QPushButton(str(i))
            btn.setFixedSize(22, 22)
            btn.setStyleSheet("background-color: #e0e0e0; color: #333; font-weight: bold; border-radius: 4px;")
            btn.clicked.connect(lambda checked, idx=i: self.on_cond_clicked(idx))
            self.cond_buttons.append(btn)
            # 2ì¤„ë¡œ ë°°ì¹˜ (0~9: 1ì—´, 10~19: 2ì—´) -> 10ê°œì”© ëŠì–´ì„œ ë°°ì¹˜
            row = i // 10
            col = i % 10
            self.cond_btn_layout.addWidget(btn, row, col)
        
        settings_layout.addWidget(cond_label)
        settings_layout.addLayout(self.cond_btn_layout)

        # Profit, Loss & Max Stocks (Horizontal)
        top_settings_layout = QHBoxLayout()
        
        # Profit
        top_settings_layout.addWidget(QLabel("ìµì ˆ"))
        self.input_profit = QLineEdit()
        self.input_profit.setFixedWidth(45)
        self.input_profit.setStyleSheet("border: 2px solid #dc3545; border-radius: 4px; padding: 3px; font-weight: bold;")
        top_settings_layout.addWidget(self.input_profit)
        
        top_settings_layout.addSpacing(5)
        
        # Loss
        top_settings_layout.addWidget(QLabel("ì†ì ˆ"))
        self.input_loss = QLineEdit()
        self.input_loss.setFixedWidth(45)
        self.input_loss.setStyleSheet("border: 2px solid #007bff; border-radius: 4px; padding: 3px; font-weight: bold;")
        top_settings_layout.addWidget(self.input_loss)

        top_settings_layout.addSpacing(5)

        # Max Stocks (Shortened label for horizontal fit)
        top_settings_layout.addWidget(QLabel("ì¢…ëª©ìˆ˜"))
        self.input_max = QLineEdit()
        self.input_max.setFixedWidth(35)
        self.input_max.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.input_max.setStyleSheet("border: 2px solid black; border-radius: 4px; padding: 3px; font-weight: bold;")
        top_settings_layout.addWidget(self.input_max)
        
        top_settings_layout.addStretch()
        settings_layout.addLayout(top_settings_layout)

        # Time Settings (Horizontal)
        time_layout = QHBoxLayout()
        
        # Start
        time_layout.addWidget(QLabel("ì‹œì‘"))
        self.input_start_time = QLineEdit()
        self.input_start_time.setFixedWidth(50)
        self.input_start_time.setAlignment(Qt.AlignmentFlag.AlignCenter)
        time_layout.addWidget(self.input_start_time)
        
        time_layout.addSpacing(5)
        
        # End
        time_layout.addWidget(QLabel("ì¢…ë£Œ"))
        self.input_end_time = QLineEdit()
        self.input_end_time.setFixedWidth(50)
        self.input_end_time.setAlignment(Qt.AlignmentFlag.AlignCenter)
        time_layout.addWidget(self.input_end_time)
        
        # ğŸ”” ì•ŒëŒ í•´ì œ ë²„íŠ¼
        self.btn_alarm_stop = QPushButton("ğŸ”•")
        self.btn_alarm_stop.setToolTip("ì•ŒëŒ í•´ì œ")
        self.btn_alarm_stop.setFixedWidth(40)
        self.btn_alarm_stop.setFixedHeight(30)
        self.btn_alarm_stop.clicked.connect(self.stop_alarm)
        self.btn_alarm_stop.setEnabled(False)
        self.btn_alarm_stop.setStyleSheet("""
            QPushButton {
                background-color: #f8f9fa;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-size: 16px;
                color: #aaa;
            }
            QPushButton:enabled {
                background-color: #ffc107; /* ì¢… ëª¨ì–‘ì´ ìš¸ë¦´ ë•ŒëŠ” ë…¸ë€ìƒ‰ */
                color: #000;
                border: 1px solid #e0a800;
            }
        """)
        time_layout.addSpacing(10)
        time_layout.addWidget(self.btn_alarm_stop)
        time_layout.addStretch()
        settings_layout.addLayout(time_layout)

        # ğŸ’ Buying Strategy Group (Revised for Color Matching)
        strategy_group = QGroupBox("ğŸ’ ë§¤ìˆ˜ ì „ëµ (Buying Strategy)")
        strategy_group.setStyleSheet("QGroupBox { background-color: #ffffff; border: 1px solid #ccc; border-radius: 8px; margin-top: 10px; padding: 10px; font-weight: bold; }")
        strat_vbox = QVBoxLayout()
        strat_vbox.setSpacing(8)

        # 1. Qty Mode (Red Border)
        qty_layout = QHBoxLayout()
        lbl_qty = QLabel("ğŸ”´ 1ì£¼")
        lbl_qty.setFixedWidth(50)
        self.input_qty_val = QLineEdit("1")
        self.input_qty_val.setReadOnly(True) # [ìˆ˜ì •] 1ì£¼ ê³ ì • ì‚¬ì–‘ ë°˜ì˜ (ìˆ˜ì • ë¶ˆê°€)
        self.input_qty_val.setStyleSheet("background-color: #f0f0f0; border: 2px solid #dc3545; border-radius: 5px; padding: 4px; font-weight: bold; color: #555;")
        qty_layout.addWidget(lbl_qty)
        qty_layout.addWidget(self.input_qty_val)
        qty_layout.addWidget(QLabel("ì£¼"))
        strat_vbox.addLayout(qty_layout)

        # 2. Amount Mode (Green Border)
        amt_layout = QHBoxLayout()
        lbl_amt = QLabel("ğŸŸ¢ ê¸ˆì•¡")
        lbl_amt.setFixedWidth(50)
        self.input_amt_val = QLineEdit("100,000")
        self.input_amt_val.setStyleSheet("border: 2px solid #28a745; border-radius: 5px; padding: 4px; font-weight: bold;")
        self.input_amt_val.textEdited.connect(lambda: self.format_comma(self.input_amt_val))
        amt_layout.addWidget(lbl_amt)
        amt_layout.addWidget(self.input_amt_val)
        amt_layout.addWidget(QLabel("ì›"))
        strat_vbox.addLayout(amt_layout)

        # 3. Percent Mode (Blue Border)
        pct_layout = QHBoxLayout()
        lbl_pct = QLabel("ğŸ”µ ë¹„ìœ¨")
        lbl_pct.setFixedWidth(50)
        self.input_pct_val = QLineEdit("10")
        self.input_pct_val.setStyleSheet("border: 2px solid #007bff; border-radius: 5px; padding: 4px; font-weight: bold;")
        pct_layout.addWidget(lbl_pct)
        pct_layout.addWidget(self.input_pct_val)
        pct_layout.addWidget(QLabel("%"))
        strat_vbox.addLayout(pct_layout)

        strategy_group.setLayout(strat_vbox)
        settings_layout.addWidget(strategy_group)

        # Save & Profile Slots Layout
        save_profile_layout = QHBoxLayout()
        
        self.btn_save = QPushButton("ğŸ’¾")
        self.btn_save.setToolTip("ì„¤ì • ì €ì¥")
        self.btn_save.setFixedSize(45, 45) # [ìˆ˜ì •] í¬ê¸° í™•ëŒ€
        self.btn_save.setStyleSheet("background-color: #6c757d; border-radius: 4px; color: white; border: 1px solid #5a6268; font-size: 28px;")
        self.btn_save.clicked.connect(self.on_save_button_clicked)
        save_profile_layout.addWidget(self.btn_save) # Ratio ì œê±°

        save_profile_layout.addSpacing(5)

        # [ìˆ˜ì •] ì‹œí€€ìŠ¤ ìë™ ë²„íŠ¼ (ì²´í¬ë°•ìŠ¤ ëŒ€ì²´)
        # ì•„ì´ì½˜ë§Œ ìˆëŠ” ì²´í¬ ê°€ëŠ¥í•œ ë²„íŠ¼ìœ¼ë¡œ ë³€ê²½. ì¼œì§€ë©´ â–¶ ì ë©¸
        self.btn_seq_auto = QPushButton("â–¶")
        self.btn_seq_auto.setCheckable(True)
        self.btn_seq_auto.setFixedSize(45, 45) # [ìˆ˜ì •] í¬ê¸° í™•ëŒ€
        self.btn_seq_auto.setToolTip("ì‹œí€€ìŠ¤ ìë™ ëª¨ë“œ (í´ë¦­í•˜ì—¬ ON/OFF)\nON ì‹œ: â–¶ê°€ ì ë©¸í•˜ë©° ì¢…ë£Œ ì‹œê°„ ë„ë‹¬ ì‹œ ë‹¤ìŒ í”„ë¡œí•„ë¡œ ì „í™˜\nOFF ì‹œ: ì •ì§€ ìƒíƒœ, ì•ŒëŒë§Œ ìš¸ë¦¼")
        self.btn_seq_auto.setStyleSheet("""
            QPushButton { background-color: #ffffff; border: 1px solid #999; border-radius: 4px; color: #ccc; font-size: 28px; font-weight: bold; }
            QPushButton:checked { background-color: #e0e0e0; border: 1px solid #666; color: #28a745; }
        """)
        self.btn_seq_auto.clicked.connect(self.on_seq_auto_toggled)
        save_profile_layout.addWidget(self.btn_seq_auto)
        
        # ì‹œí€€ìŠ¤ ë²„íŠ¼ìš© íƒ€ì´ë¨¸ (1ì´ˆ ê°„ê²© ì ë©¸)
        self.seq_blink_timer = QTimer(self)
        self.seq_blink_timer.setInterval(1000)
        self.seq_blink_timer.timeout.connect(self.blink_seq_button)
        self.is_seq_blink_on = False

        save_profile_layout.addSpacing(10) # ê°„ê²© ì¡°ì •
        
        self.profile_buttons = []
        for i in range(1, 4):
            btn = QPushButton(str(i))
            btn.setFixedSize(35, 35) # í¬ê¸° ìœ ì§€
            # [ìˆ˜ì •] í…ìŠ¤íŠ¸ê°€ ì•ˆ ë³´ì¸ë‹¤ë©´: í°íŠ¸ ê°•ì œ ì„¤ì • ë° í…ìŠ¤íŠ¸ ì •ë ¬, ìƒ‰ìƒ ëŒ€ë¹„ ê°•í™”
            btn.setStyleSheet("background-color: #ffffff; border: 1px solid #999; border-radius: 4px; font-weight: 900; color: #000000; padding: 0px; font-size: 16px; font-family: 'Arial';")
            btn.clicked.connect(lambda checked, idx=i: self.on_profile_clicked(idx))
            save_profile_layout.addWidget(btn)
            self.profile_buttons.append(btn)
            
        settings_layout.addLayout(save_profile_layout)
        
        settings_layout.addStretch()
        settings_group.setLayout(settings_layout)
        settings_group.setContentsMargins(5, 5, 5, 5) # ì—¬ë°± ì¶•ì†Œ
        left_layout.addWidget(settings_group)

        # 2. Real-time List
        rt_group = QGroupBox("ğŸ“‹ ì‹¤ì‹œê°„ ì¡°ê±´ì‹")
        rt_layout = QVBoxLayout()
        rt_layout.setContentsMargins(5, 5, 5, 5) # ì—¬ë°± ìµœì†Œí™”
        rt_layout.setSpacing(2)
        self.rt_list = QTextEdit()
        self.rt_list.setReadOnly(True)
        self.rt_list.setStyleSheet("background-color: white; color: black; border: 1px solid #ddd;")
        rt_layout.addWidget(self.rt_list)
        
        rt_group.setLayout(rt_layout)
        left_layout.addWidget(rt_group)

        # === Right Panel: Controls & Logs ===

        right_panel = QFrame()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)

        # Header Layout Removed (Moved to Global)

        # Control Buttons
        btn_layout = QHBoxLayout()
        
        self.btn_start = QPushButton("â–¶ START")
        self.btn_start.setStyleSheet("background-color: #28a745; height: 35px; font-size: 14px;")
        self.btn_start.clicked.connect(self.on_start_clicked)
        
        self.btn_stop = QPushButton("â¹ STOP")
        self.btn_stop.setStyleSheet("background-color: #dc3545; height: 35px; font-size: 14px;")
        def on_stop():
            self.animate_button_click(self.btn_stop)
            self.worker.schedule_command('stop')
        self.btn_stop.clicked.connect(on_stop)
        
        self.btn_report = QPushButton("ğŸ“Š REPORT")
        self.btn_report.setStyleSheet("background-color: #17a2b8; height: 35px; font-size: 14px;")
        def on_report():
            self.animate_button_click(self.btn_report)
            self.worker.schedule_command('report')
        self.btn_report.clicked.connect(on_report)

        btn_layout.addWidget(self.btn_start)
        btn_layout.addWidget(self.btn_stop)
        btn_layout.addWidget(self.btn_report)
        right_layout.addLayout(btn_layout)

        # System Log
        log_group = QGroupBox("ğŸ“„ System Logs")
        log_layout = QVBoxLayout()
        self.log_text = QTextEdit()
        self.log_text.setReadOnly(True)
        log_layout.addWidget(self.log_text)
        log_group.setLayout(log_layout)
        right_layout.addWidget(log_group)

        # Command Input
        input_layout = QHBoxLayout()
        input_label = QLabel("ëª…ë ¹ì–´ ì…ë ¥:")
        self.cmd_input = QLineEdit()
        self.cmd_input.returnPressed.connect(self.send_command)
        
        btn_send = QPushButton("ì „ì†¡")
        btn_send.setStyleSheet("background-color: #fff; color: #333; border: 1px solid #ccc;")
        btn_send.clicked.connect(self.send_command)

        input_layout.addWidget(input_label)
        input_layout.addWidget(self.cmd_input)
        input_layout.addWidget(btn_send)
        right_layout.addLayout(input_layout)

        # Add panels to body layout
        body_layout.addWidget(left_panel)
        body_layout.addWidget(right_panel)
        body_layout.setStretch(1, 1) # Right panel takes remaining space

    def animate_button_click(self, btn):
        """ë²„íŠ¼ í´ë¦­ ì‹œ ìƒ‰ìƒ ë°˜ì „ ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼"""
        original_style = btn.styleSheet()
        # [íš¨ê³¼] ì ì‹œ ë°ê²Œ/ì–´ë‘¡ê²Œ ë³€ê²½
        btn.setStyleSheet("background-color: #555; color: white; border: 2px solid white;")
        QTimer.singleShot(150, lambda: btn.setStyleSheet(original_style))

    def on_start_clicked(self, force=False):
        # [ì‹ ê·œ] ë²„íŠ¼ ì• ë‹ˆë©”ì´ì…˜ ë° ì¤‘ë³µ ë°©ì§€
        self.animate_button_click(self.btn_start)
        
        # [ìˆ˜ì •] forceê°€ Trueì´ë©´ ë²„íŠ¼ ìƒíƒœì™€ ê´€ê³„ì—†ì´ ì§„í–‰ (ì‹œí€€ìŠ¤ ì „í™˜ìš©)
        if not force and not self.btn_start.isEnabled(): return
        self.btn_start.setEnabled(False) # ì¦‰ì‹œ ë¹„í™œì„±í™”í•˜ì—¬ ì¤‘ë³µ í´ë¦­ ë°©ì§€

        # 1. UIì˜ í˜„ì¬ ëª¨ë“  ì„¤ì •ì„ ê¸°ë³¸(root) ì„¤ì •ì— ë™ê¸°í™”
        try:
            # [ìˆ˜ì •] restart_if_running=Falseë¡œ ì„¤ì •í•˜ì—¬ on_start_clicked ë‚´ë¶€ì—ì„œì˜ ë¬´í•œ ë£¨í”„/ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
            self.save_settings(restart_if_running=False) 
            
            # [ìˆ˜ì •] ë¡œê·¸ ìˆœì„œ ì¡°ì • (ì—”ì§„ ì‹œì‘ ì´í›„ì— ë‚˜ì˜¤ë„ë¡ ì •ë³´ë¥¼ ì „ë‹¬)
            target_profile = f"{self.current_profile_idx}ë²ˆ í”„ë¡œí•„" if self.current_profile_idx else "ê¸°ë³¸ ì„¤ì •"
            
        except Exception as e:
            self.append_log(f"âš ï¸ ì„¤ì • ë™ê¸°í™” ì‹¤íŒ¨: {e}")
            target_profile = None
            self.btn_start.setEnabled(True) # ì‹¤íŒ¨ ì‹œ ë‹¤ì‹œ í™œì„±í™”
            
        # 2. ì‹œì‘ ëª…ë ¹ ì „ë‹¬ (target_profileì„ ì¸ìë¡œ ì „ë‹¬í•˜ì—¬ ì—”ì§„ ê°€ë™ í›„ ì¶œë ¥ë˜ê²Œ í•¨)
        QTimer.singleShot(500, lambda: self.worker.schedule_command('start', target_profile))

    def setup_worker(self):
        self.worker = AsyncWorker(self)
        self.worker.signals.log_signal.connect(self.append_log)
        self.worker.signals.status_signal.connect(self.update_status_ui)
        self.worker.signals.clr_signal.connect(self.log_text.clear)
        self.worker.signals.request_log_signal.connect(self.save_logs_to_file)
        self.worker.start()

    def update_status_ui(self, status):
        if status == "RUNNING":
            self.lbl_status.setText("â— RUNNING")
            self.lbl_status.setStyleSheet("color: #28a745; margin-left: 10px;")
            self.btn_start.setEnabled(False)
            self.btn_start.setStyleSheet("background-color: #6c757d; height: 35px; font-size: 14px;")
        elif status == "WAITING":
            self.lbl_status.setText("â— WAITING")
            self.lbl_status.setStyleSheet("color: #ffc107; margin-left: 10px;") # ë…¸ë€ìƒ‰
            # [ìˆ˜ì •] WAITING ìƒíƒœì—ì„œë„ ì‚¬ìš©ìê°€ ì›í•˜ë©´ ë‹¤ì‹œ STARTë¥¼ ëˆ„ë¥¼ ìˆ˜ ìˆë„ë¡ í™œì„±í™” (DEAD ë²„íŠ¼ ë°©ì§€)
            self.btn_start.setEnabled(True) 
            self.btn_start.setStyleSheet("background-color: #28a745; height: 35px; font-size: 14px;")
        else:
            self.lbl_status.setText("â— READY")
            self.lbl_status.setStyleSheet("color: #6c757d; margin-left: 10px;")
            self.btn_start.setEnabled(True)
            self.btn_start.setStyleSheet("background-color: #28a745; height: 35px; font-size: 14px;")

    def append_log(self, text):
        # [ì¶”ê°€] ë¶ˆí•„ìš”í•˜ê±°ë‚˜ ê¸°ìˆ ì ì¸ ë¡œê·¸ í•„í„°ë§
        filter_keywords = [
            "Disconnected from WebSocket server",
            "Message sent:",
            "ì‹¤ì‹œê°„ ì‹œì„¸ ì„œë²„ ì‘ë‹µ ìˆ˜ì‹ (data):",
            "ì„œë²„ì™€ ì—°ê²°ì„ ì‹œë„ ì¤‘ì…ë‹ˆë‹¤.",
            "ì‹¤ì‹œê°„ ì‹œì„¸ ì„œë²„ë¡œ ë¡œê·¸ì¸ íŒ¨í‚·ì„ ì „ì†¡í•©ë‹ˆë‹¤.",
            "ë¡œê·¸ì¸ ì„±ê³µí•˜ì˜€ìŠµë‹ˆë‹¤.",
            "Connection error:"
        ]
        
        if any(keyword in text for keyword in filter_keywords):
            return

        timestamp = datetime.datetime.now().strftime("%H:%M:%S")
        
        # [ìˆ˜ì •] ë“¤ì—¬ì“°ê¸° ë° ì •ë ¬ ì²˜ë¦¬
        # ì‹œê°„ ì˜ì—­([HH:MM:SS])ì„ ê³ ì • ë„ˆë¹„ë¡œ ë‘ê³ , ë©”ì‹œì§€ëŠ” ê·¸ ë„ˆë¹„ë§Œí¼ ì™¼ìª½ ë§ˆì§„ì„ ì£¼ì–´ ì •ë ¬
        text_html = text.replace('\n', '<br>')
        
        # TABLE í˜•íƒœì˜ ë ˆì´ì•„ì›ƒì„ ì‚¬ìš©í•˜ì—¬ ì‹œê°„ê³¼ ë©”ì‹œì§€ë¥¼ ë¶„ë¦¬
        full_html = f"""
        <table border="0" cellpadding="0" cellspacing="0" style="margin-bottom: 2px;">
            <tr>
                <td valign="top" style="width: 70px; color: #ccc; font-family: 'Courier New'; font-size: 11px; white-space: nowrap;">
                    [{timestamp}]
                </td>
                <td valign="top" style="padding-left: 5px; color: #00ff00; font-family: 'Consolas', 'Monospace';">
                    {text_html if '<font color' in text_html or '<span style' in text_html else f"<span>{text_html}</span>"}
                </td>
            </tr>
        </table>
        """
        self.log_text.append(full_html)
        
        # ì¡°ê±´ì‹ ëª©ë¡ì´ë©´ ì™¼ìª½ íŒ¨ë„ì—ëŠ” **ì„ íƒëœ ì¡°ê±´ì‹ë§Œ** í•„í„°ë§í•˜ì—¬ í‘œì‹œ
        if "ğŸ“‹ [ì¡°ê±´ì‹ ëª©ë¡]" in text:
            filtered_msg = ""
            lines = text.split('\n')
            
            # í˜„ì¬ UIì—ì„œ ì²´í¬ëœ ë²ˆí˜¸ë“¤ ê°€ì ¸ì˜¤ê¸°
            checked_indices = [str(i) for i, btn in enumerate(self.cond_buttons) if btn.isChecked()]
            
            found_any = False
            for line in lines:
                if line.startswith('â€¢'):
                    # í¬ë§·: "â€¢ 0: ì¡°ê±´ì‹ì´ë¦„" -> ":" ê¸°ì¤€ìœ¼ë¡œ ë¶„ë¦¬
                    try:
                        parts = line.split(':')
                        idx = parts[0].replace('â€¢', '').strip()
                        
                        if idx in checked_indices:
                            filtered_msg += line + "\n"
                            found_any = True
                    except:
                        pass
            
            if not found_any:
                filtered_msg += "(ì„ íƒëœ ì¡°ê±´ì‹ì´ ëª©ë¡ì— ì—†ìŠµë‹ˆë‹¤)"
                
            self.rt_list.setText(filtered_msg)
            
        # Auto scroll
        sb = self.log_text.verticalScrollBar()
        sb.setValue(sb.maximum())

    def save_logs_to_file(self):
        """í˜„ì¬ ë¡œê·¸ì°½ì˜ ë‚´ìš©ì„ Log_YYYYMMDD_y.txt í˜•ì‹ìœ¼ë¡œ ì €ì¥í•©ë‹ˆë‹¤."""
        try:
            # 1. ì¼ë°˜ í…ìŠ¤íŠ¸ ì¶”ì¶œ (HTML ì œê±°ëœ í“¨ì–´ í…ìŠ¤íŠ¸)
            raw_text = self.log_text.toPlainText()
            
            # 2. ë‚ ì§œ ë° ì¼ë ¬ë²ˆí˜¸ ê²°ì •
            today_str = datetime.datetime.now().strftime("%Y%m%d")
            y = 1
            while True:
                filename = f"Log_{today_str}_{y}.txt"
                filepath = os.path.join(self.script_dir, filename)
                if not os.path.exists(filepath):
                    break
                y += 1
            
            # 3. íŒŒì¼ ì €ì¥
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(raw_text)
            
            msg = f"ğŸ’¾ ë¡œê·¸ íŒŒì¼ ì €ì¥ ì™„ë£Œ: {filename}"
            self.append_log(msg)
            
            # í…”ë ˆê·¸ë¨ìœ¼ë¡œë„ ì•Œë¦¼ (tel_send ëª¨ë“ˆ ì§ì ‘ ì‚¬ìš©)
            from tel_send import tel_send
            tel_send(msg)
            
        except Exception as e:
            err_msg = f"âŒ ë¡œê·¸ ì €ì¥ ì‹¤íŒ¨: {e}"
            self.append_log(err_msg)
            from tel_send import tel_send
            tel_send(err_msg)


    def send_command(self):
        cmd = self.cmd_input.text().strip()
        if cmd:
            if cmd.upper() == 'PRINT':
                self.export_log()
            elif cmd.lower() == 'clr':
                self.log_text.clear()
                self.append_log("ğŸ§¹ ë¡œê·¸ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.")
            else:
                self.worker.schedule_command('custom', cmd)
            self.cmd_input.clear()

    def export_log(self):
        try:
            now_str = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"KIPOSTOCK_LOG_{now_str}.txt"
            
            # í˜„ì¬ ì‹¤í–‰ íŒŒì¼ ìœ„ì¹˜ì— ì €ì¥
            log_path = os.path.join(self.script_dir, filename)
            
            content = self.log_text.toPlainText()
            
            with open(log_path, 'w', encoding='utf-8') as f:
                f.write(content)
                
            # [ìˆ˜ì •] ë¡œê·¸ ì €ì¥ ë©”ì‹œì§€ ìŠ¤íƒ€ì¼ë§: ë“¤ì—¬ì“°ê¸°, ì´íƒ¤ë¦­, ë°‘ì¤„ ì ìš©
            # HTML íƒœê·¸ëŠ” append_log(html=True) ì²˜ë¦¬ê°€ í•„ìš”í•  ìˆ˜ ìˆìœ¼ë‚˜ 
            # í˜„ì¬ append_logê°€ ëª¨ë“  ì…ë ¥ì„ html_textë¡œ ê°ì‹¸ë¯€ë¡œ ìˆ˜ë™ìœ¼ë¡œ í¬ë§·íŒ…
            save_msg = f"ğŸ’¾ ë¡œê·¸ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤:<br>" + "&nbsp;"*11 + f"<u><i>{filename}</i></u>"
            self.append_log(save_msg)
            
            # ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼ (ì„ íƒ ì‚¬í•­)
            # QMessageBox.information(self, "ë¡œê·¸ ì €ì¥", f"ë¡œê·¸ê°€ íŒŒì¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.\n{filename}")
            
        except Exception as e:
            self.append_log(f"âŒ ë¡œê·¸ ì €ì¥ ì‹¤íŒ¨: {e}")

    def on_cond_clicked(self, idx):
        # State: 0 (Off/Gray), 1 (Red/Qty), 2 (Green/Amt), 3 (Blue/Pct)
        self.cond_states[idx] = (self.cond_states[idx] + 1) % 4
        self.update_button_style(idx)
        # [ì‹ ê·œ] ë¦¬ìŠ¤íŠ¸ ì¦‰ì‹œ ê°±ì‹ 
        self.refresh_condition_list_ui()
        
        # [ì‹ ê·œ] ë™ì  ë°˜ì˜ (ì„¤ì • ì €ì¥ í›„ ì—”ì§„ì— ì•Œë¦¼)
        self.save_settings(show_limit_warning=False, restart_if_running=False, quiet=True)
        if self.lbl_status.text() == "â— RUNNING":
            # workerì— refresh_conditions ëª…ë ¹ ì „ë‹¬ (settings.jsonì„ ë‹¤ì‹œ ì½ì–´ì„œ ë°˜ì˜)
            self.worker.schedule_command('refresh_conditions')

    def update_button_style(self, idx):
        # [ì‹ ê·œ] ë²ˆí˜¸ê°€ ì•ˆ ë³´ì´ëŠ” ë¬¸ì œ í•´ê²°ì„ ìœ„í•´ í…ìŠ¤íŠ¸ ê°•ì œ ì„¤ì •
        self.cond_buttons[idx].setText(str(idx))
        
        # State colors: Off(Gray), ğŸ”´(Red), ğŸŸ¢(Green), ğŸ”µ(Blue)
        colors = {0: "#e0e0e0", 1: "#dc3545", 2: "#28a745", 3: "#007bff"}
        text_colors = {0: "#333", 1: "white", 2: "white", 3: "white"}
        
        c = colors.get(self.cond_states[idx], "#e0e0e0")
        tc = text_colors.get(self.cond_states[idx], "#333")
        
        # [ìˆ˜ì •] ë²ˆí˜¸ê°€ ì¤‘ì•™ì— ì˜ ë³´ì´ë„ë¡ í°íŠ¸ í¬ê¸°ì™€ íŒ¨ë”© ì¡°ì •
        self.cond_buttons[idx].setStyleSheet(f"""
            QPushButton {{ 
                background-color: {c}; 
                color: {tc}; 
                font-weight: bold; 
                border-radius: 4px;
                border: 1px solid #999;
                font-size: 11px;
                padding: 0px;
            }}
        """)

    def refresh_condition_list_ui(self):
        """ì‹¤ì‹œê°„ ì¡°ê±´ì‹ ë¦¬ìŠ¤íŠ¸ íŒ¨ë„ì„ í˜„ì¬ ì„ íƒëœ ìƒíƒœì— ë§ì¶° ê°±ì‹ """
        try:
            # 1. ê³ ìœ í•œ ê²€ìƒ‰ì‹ ì´ë¦„ ì‚¬ì „ ì ‘ê·¼ (Worker -> ChatCommand -> RealTimeSearch)
            condition_map = {}
            if self.worker and hasattr(self.worker, 'chat_command') and hasattr(self.worker.chat_command, 'rt_search'):
                 condition_map = self.worker.chat_command.rt_search.condition_map

            # html = "<b>[ í˜„ì¬ ì„ íƒëœ ì¡°ê±´ì‹ ]</b><br><br>" # ì œê±° ìš”ì²­
            html = ""
            active_count = 0
            
            # 2. ë²„íŠ¼ ìƒíƒœ ìˆœíšŒ
            mode_names = {1: "1ì£¼", 2: "ê¸ˆì•¡", 3: "ë¹„ìœ¨"}
            mode_colors = {1: "#dc3545", 2: "#28a745", 3: "#007bff"}
            
            for i, state in enumerate(self.cond_states):
                if state > 0:
                    active_count += 1
                    name = condition_map.get(str(i), f"ì¡°ê±´ì‹ {i}")
                    m_name = mode_names[state]
                    m_color = mode_colors[state]
                    
                    # HTML í¬ë§·: ìƒ‰ìƒ ì ìš©ëœ ì´ë¦„ê³¼ ëª¨ë“œ í‘œì‹œ
                    html += f"&nbsp;â€¢ <span style='color:{m_color};'><b>{i}: {name}</b> ({m_name})</span><br>"
            
            if active_count == 0:
                html = "<br><center>(ì„ íƒëœ ì¡°ê±´ì‹ì´ ì—†ìŠµë‹ˆë‹¤)</center>"
                
            self.rt_list.setHtml(html)
            
        except Exception as e:
            print(f"âš ï¸ ë¦¬ìŠ¤íŠ¸ ê°±ì‹  ì‹¤íŒ¨: {e}")

    def format_comma(self, line_edit):
        text = line_edit.text().replace(',', '')
        if not text: return
        try:
            val = int(text)
            line_edit.setText(f"{val:,}")
        except:
            pass

    def toggle_blink(self):
        if not self.alarm_playing:
            self.blink_timer.stop()
            return
            
        self.is_blink_on = not self.is_blink_on
        if self.is_blink_on:
            self.btn_alarm_stop.setStyleSheet("""
                QPushButton { background-color: #ffc107; color: #000; border: 1px solid #e0a800; border-radius: 4px; font-size: 16px; }
            """)
        else:
            self.btn_alarm_stop.setStyleSheet("""
                QPushButton { background-color: #dc3545; color: #fff; border: 1px solid #c82333; border-radius: 4px; font-size: 16px; }
            """)

    def check_alarm(self):
        # ì´ë¯¸ ìš¸ë¦¬ê³  ìˆìœ¼ë©´ íŒ¨ìŠ¤
        if self.alarm_playing:
            return

        # í”„ë¡œê·¸ë¨ ì‹œì‘ í›„ 5ì´ˆê°„ì€ ì•ŒëŒ ì²´í¬ ìŠ¤í‚µ (ì´ˆê¸°í™” ì•ˆì •í™” ëŒ€ê¸°)
        if (datetime.datetime.now() - self.app_start_time).total_seconds() < 5:
            return

        # [ì‹ ê·œ] ìƒë‹¨ ì‹œê³„ ì—…ë°ì´íŠ¸
        now = datetime.datetime.now()
        self.lbl_clock.setText(now.strftime("%H:%M:%S"))

        current_time_str = now.strftime("%H:%M")
        
        # -------------------------------------------------------------
        # âœ… 1. ì‹œì‘ ì‹œê°„ ì²´í¬ (Start Time Check)
        # -------------------------------------------------------------
        # ì„¤ì •ëœ ì‹œì‘ ì‹œê°„ê³¼ ì¼ì¹˜í•˜ê³ , í˜„ì¬ ìƒíƒœê°€ READYë¼ë©´ ìë™ ì‹œì‘
        try:
            start_time_str = self.input_start_time.text().strip()
            # ì‹œê°„ í¬ë§· ì •ê·œí™”
            target_start = datetime.datetime.strptime(start_time_str, "%H:%M").strftime("%H:%M")
        except:
            target_start = start_time_str

        if current_time_str == target_start:
            # [ìˆ˜ì •] ë¶„ ë‹¨ìœ„ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ (ì´ë¯¸ ì‹¤í–‰í•œ ì‹œê°„ëŒ€ë©´ íŒ¨ìŠ¤)
            if self.last_auto_start_time != current_time_str:
                # ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ (ë¶„ ë‹¨ìœ„ ì²´í¬ì´ë¯€ë¡œ 1ë¶„ ë™ì•ˆ ê³„ì† ì‹¤í–‰ë  ìˆ˜ ìˆìŒ -> last_check_time ë“±ìœ¼ë¡œ ë°©ì§€ í•„ìš”í•˜ì§€ë§Œ 
                # ì—¬ê¸°ì„œëŠ” ìƒíƒœê°€ READYì¼ ë•Œë§Œ ë™ì‘í•˜ë¯€ë¡œ ìì—°ìŠ¤ëŸ½ê²Œ ë°©ì–´ë¨)
                if self.lbl_status.text() == "â— READY":
                    self.last_auto_start_time = current_time_str # ì‹¤í–‰ ì‹œê°„ ê¸°ë¡
                    self.append_log(f"â° ì‹œì‘ ì‹œê°„({target_start}) ë„ë‹¬: ìë™ ì‹œì‘í•©ë‹ˆë‹¤.")
                    # ì§§ì€ ë¹„í”„ìŒ
                    winsound.MessageBeep(winsound.MB_ICONASTERISK)
                    # ì‹œì‘ ëª…ë ¹ ì‹¤í–‰
                    self.on_start_clicked() # ì €ì¥ í›„ ì‹œì‘ ë¡œì§ ì¬ì‚¬ìš©

        # -------------------------------------------------------------
        # âœ… 2. ì¢…ë£Œ ì‹œê°„ ì²´í¬ (End Time Check)
        # -------------------------------------------------------------
        end_time_str = self.input_end_time.text().strip()
        try:
            target_end = datetime.datetime.strptime(end_time_str, "%H:%M").strftime("%H:%M")
        except:
            target_end = end_time_str

        # ì‹œê°„ì´ ì¼ì¹˜í•˜ê³ , ë°©ê¸ˆ ëˆ ì‹œê°„(last_alarm_time)ì´ ì•„ë‹ˆë¼ë©´
        # [ìˆ˜ì •] ë™ì¼í•œ ë¶„ì— ì‹œì‘ê³¼ ì¢…ë£Œê°€ ë™ì‹œì— ì¼ì–´ë‚˜ëŠ” ë ˆì´ìŠ¤ ì»¨ë””ì…˜ ë°©ì§€
        if current_time_str == target_end:
            if self.last_alarm_time != current_time_str and self.last_auto_start_time != current_time_str:
                self.handle_end_time_event(current_time_str)

 

    # def play_subprocess_sound(self):  <-- ë©”ì„œë“œ ì œê±°
    #     pass

    def stop_alarm(self):
        if self.alarm_playing:
            # ì†Œë¦¬ ì¤‘ë‹¨
            try:
                winsound.PlaySound(None, winsound.SND_PURGE)
            except: pass
            
            self.alarm_playing = False
            self.last_alarm_time = datetime.datetime.now().strftime("%H:%M") # í˜„ì¬ ë¶„ì—ëŠ” ë‹¤ì‹œ ì•ˆ ìš¸ë¦¼
            
            self.blink_timer.stop() # ê¹œë¹¡ì„ ì¤‘ë‹¨
            self.btn_alarm_stop.setEnabled(False)
            self.btn_alarm_stop.setText("ğŸ”•")
            self.btn_alarm_stop.setStyleSheet("""
                QPushButton {
                    background-color: #f8f9fa;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    font-size: 16px;
                    color: #aaa;
                }
            """)
            self.append_log("ğŸ”• ì•ŒëŒì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.")

    def update_strategy_ui(self, from_user_click=False):
        # Legacy stub for backward compatibility if called elsewhere
        pass

    def format_input_value(self, text):
        # Legacy stub
        pass

    def load_settings_to_ui(self, profile_idx=None, keep_seq_auto=False):
        try:
            with open(self.settings_file, 'r', encoding='utf-8') as f:
                settings = json.load(f)
            
            target = settings
            if profile_idx is not None:
                profiles = settings.get('profiles', {})
                target = profiles.get(str(profile_idx))
                if not target:
                    self.append_log(f"âš ï¸ í”„ë¡œí•„ {profile_idx}ë²ˆ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
                    return
                self.append_log(f"ğŸ“‚ í”„ë¡œí•„ {profile_idx}ë²ˆ ì„¤ì •ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.")

            self.input_profit.setText(str(target.get('take_profit_rate', '12.0')))
            self.input_loss.setText(str(target.get('stop_loss_rate', '-1.2')))
            self.input_max.setText(str(target.get('max_stocks', '20')))
            
            # Condition Button Set
            seq_data = target.get('search_seq', [])
            if isinstance(seq_data, str):
                try:
                    parsed = ast.literal_eval(seq_data)
                    seq_data = parsed if isinstance(parsed, list) else [seq_data]
                except: seq_data = [seq_data]
            elif isinstance(seq_data, int): seq_data = [str(seq_data)]
                
            seq_set = set(map(str, seq_data))
            for i, btn in enumerate(self.cond_buttons):
                btn.setChecked(str(i) in seq_set)
            
            self.input_start_time.setText(target.get('start_time', '09:00'))
            self.input_end_time.setText(target.get('end_time', '15:20'))
            self.input_qty_val.setText(str(target.get('qty_val', '1')))
            
            amt_val = target.get('amt_val', '100,000')
            try: amt_val = f"{int(str(amt_val).replace(',', '')):,}"
            except: pass
            self.input_amt_val.setText(amt_val)
            self.input_pct_val.setText(str(target.get('pct_val', '10')))
            
            # [ìˆ˜ì •] ì‹œí€€ìŠ¤ ë²„íŠ¼ ë¡œë“œ ë° UI ë°˜ì˜ (ì „í™˜ ì‹œì—ëŠ” í˜„ì¬ ìƒíƒœ ìœ ì§€)
            if not keep_seq_auto:
                is_seq = target.get('sequence_auto', False)
                self.btn_seq_auto.setChecked(is_seq)
                self.on_seq_auto_toggled() # ìƒíƒœì— ë”°ë¥¸ ìŠ¤íƒ€ì¼ ì ìš©
            
            # Condition 4-State logic
            strat_map = target.get('condition_strategies', {})
            active_seqs = set(map(str, seq_data)) if isinstance(seq_data, (list, set)) else set()

            for i in range(20): # [ìˆ˜ì •] 10ê°œ -> 20ê°œë¡œ í™•ì¥
                mode = strat_map.get(str(i))
                if mode == 'qty': self.cond_states[i] = 1
                elif mode == 'amount': self.cond_states[i] = 2
                elif mode == 'percent': self.cond_states[i] = 3
                else:
                    self.cond_states[i] = 1 if str(i) in active_seqs else 0
                self.update_button_style(i)
            
            # [ì‹ ê·œ] í™œì„±í™”ëœ í”„ë¡œí•„ ë²„íŠ¼ ê°•ì¡° ì²˜ë¦¬
            self.current_profile_idx = profile_idx
            self.update_profile_buttons_ui()

            # [ì‹ ê·œ] ë¡œë“œ ì§í›„ ë¦¬ìŠ¤íŠ¸ ë¦¬í”„ë ˆì‹œ ë° ìš´ì˜ ì‹œê°„ ë™ê¸°í™”
            QTimer.singleShot(500, self.refresh_condition_list_ui)
            
            # [ì‹ ê·œ] ë¡œë“œëœ ì„¤ì •ì— ë§ì¶° MarketHour ì¦‰ì‹œ ë™ê¸°í™” (WAITING ë²„ê·¸ í•´ê²°)
            try:
                sh, sm = map(int, target.get('start_time', '09:00').split(':'))
                eh, em = map(int, target.get('end_time', '15:20').split(':'))
                MarketHour.set_market_hours(sh, sm, eh, em)
            except: pass
            
        except Exception as e:
            self.append_log(f"ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: {e}")

    def save_settings(self, profile_idx=None, show_limit_warning=True, restart_if_running=True, quiet=False):
        try:
            # UI ê°’ ì½ê¸°
            tpr = self.input_profit.text()
            slr = self.input_loss.text()
            max_s = self.input_max.text()
            st = self.input_start_time.text()
            et = self.input_end_time.text()
            
            # [ìˆ˜ì •] ìš´ì˜ ì‹œê°„ ì œí•œ (09:00 ~ 15:30)
            def clamp_time(t_str, default_val):
                try:
                    h, m = map(int, t_str.strip().split(':'))
                    t_val = h * 100 + m
                    if t_val < 900: return "09:00"
                    if t_val > 1530: return "15:30"
                    return f"{h:02d}:{m:02d}"
                except: return default_val
            
            st = clamp_time(st, "09:00")
            et = clamp_time(et, "15:30")
            
            # UI ê°•ì œ ê°±ì‹ 
            self.input_start_time.setText(st)
            self.input_end_time.setText(et)
            
            selected_seq = []
            cond_strategies = {}
            mode_map = {1: 'qty', 2: 'amount', 3: 'percent'}
            
            for i, state in enumerate(self.cond_states):
                if state > 0:
                    selected_seq.append(str(i))
                    cond_strategies[str(i)] = mode_map[state]

            # [ì‹ ê·œ] 10ê°œ ì´ˆê³¼ ê²½ê³  (ì¦ê¶Œì‚¬ ì •ì±…)
            if show_limit_warning and len(selected_seq) > 10:
                msg = f"âš ï¸ [ì£¼ì˜] ì„ íƒëœ ì¡°ê±´ì‹ì´ {len(selected_seq)}ê°œì…ë‹ˆë‹¤.\nì¦ê¶Œì‚¬ API ì •ì±…ìƒ ë™ì‹œì— ìµœëŒ€ 10ê°œê¹Œì§€ë§Œ ì‹¤ì‹œê°„ ê°ì‹œê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.\nì´ˆê³¼ëœ í•­ëª©ì€ ì„œë²„ì—ì„œ ë“±ë¡ì„ ê±°ë¶€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
                QMessageBox.warning(self, "ì¡°ê±´ì‹ ê°œìˆ˜ ì´ˆê³¼", msg)
                self.append_log(msg.replace("\n", " "))

            qty_val = self.input_qty_val.text()
            amt_val = self.input_amt_val.text()
            pct_val = self.input_pct_val.text()
            
            # í˜„ì¬ ì„¤ì •ì„ ë”•ì…”ë„ˆë¦¬ë¡œ êµ¬ì„±
            current_data = {
                'take_profit_rate': float(tpr),
                'stop_loss_rate': float(slr),
                'max_stocks': int(max_s),
                'start_time': st,
                'end_time': et,
                'qty_val': qty_val,
                'amt_val': amt_val,
                'pct_val': pct_val,
                'condition_strategies': cond_strategies,
                'search_seq': selected_seq,
                'sequence_auto': self.btn_seq_auto.isChecked() # [ìˆ˜ì •] ì‹œí€€ìŠ¤ ë²„íŠ¼ ìƒíƒœ ì €ì¥
            }

            if profile_idx is not None:
                # íŠ¹ì • í”„ë¡œí•„ì— ì €ì¥
                with open(self.settings_file, 'r', encoding='utf-8') as f:
                    settings = json.load(f)
                
                if 'profiles' not in settings: settings['profiles'] = {}
                settings['profiles'][str(profile_idx)] = current_data
                
                with open(self.settings_file, 'w', encoding='utf-8') as f:
                    json.dump(settings, f, ensure_ascii=False, indent=2)
                
                # [ì‹ ê·œ] ì €ì¥ ì‹œì—ë„ MarketHour ì¦‰ì‹œ ë™ê¸°í™”
                try:
                    sh, sm = map(int, st.split(':'))
                    eh, em = map(int, et.split(':'))
                    MarketHour.set_market_hours(sh, sm, eh, em)
                except: pass

                if not quiet:
                    self.append_log(f"ğŸ’¾ í”„ë¡œí•„ {profile_idx}ë²ˆì— ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.")
                    # [ì‹ ê·œ] ì €ì¥ëœ ìƒì„¸ ì„¤ì •ê°’ ì¶œë ¥
                    summary = f"ğŸ“‹ [ì €ì¥ê°’] ìµì ˆ:{tpr}% | ì†ì ˆ:{slr}% | ì¢…ëª©ìˆ˜:{max_s} | ì‹œê°„:{st}~{et} | ì„ íƒ:{len(selected_seq)}ì¢…ëª©"
                    self.append_log(f"<font color='#28a745'>{summary}</font>")
            else:
                # [ìˆ˜ì •] ë ˆì´ìŠ¤ ì»¨ë””ì…˜ ë°©ì§€ë¥¼ ìœ„í•´ ì¼ê´„ ì—…ë°ì´íŠ¸(update_settings) ì‚¬ìš©
                root_updates = {
                    'qty_val': qty_val,
                    'amt_val': amt_val,
                    'pct_val': pct_val,
                    'condition_strategies': cond_strategies,
                    'search_seq': selected_seq,
                    'take_profit_rate': float(tpr),
                    'stop_loss_rate': float(slr),
                    'max_stocks': int(max_s),
                    'start_time': st,
                    'end_time': et
                }
                self.worker.schedule_command('update_settings', root_updates, quiet)
                
                # ì‹œê°„ ì„¤ì • ì¦‰ì‹œ ë°˜ì˜
                try:
                    sh, sm = map(int, st.split(':'))
                    eh, em = map(int, et.split(':'))
                    MarketHour.set_market_hours(sh, sm, eh, em)
                except: pass
                
                self.worker.schedule_command('condition_list', quiet)
                if hasattr(cached_setting, "_cache"): cached_setting._cache = {}
                
                # [ìˆ˜ì •] ì—”ì§„ ì¬ì‹œì‘ ì—¬ë¶€ ì œì–´ (ì¡°ê±´ì‹ ë‹¨ìˆœ ë³€ê²½ ì‹œì—ëŠ” ì¬ì‹œì‘ ì•ˆ í•¨)
                if restart_if_running and "RUNNING" in self.lbl_status.text():
                    self.worker.schedule_command('start')
                
                if not quiet:
                    self.append_log("ğŸ’¾ ê¸°ë³¸ ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.")
                    summary = f"ğŸ“‹ [ì €ì¥ê°’] ìµì ˆ:{tpr}% | ì†ì ˆ:{slr}% | ì¢…ëª©ìˆ˜:{max_s} | ì‹œê°„:{st}~{et} | ì„ íƒ:{len(selected_seq)}ì¢…ëª©"
                    self.append_log(f"<font color='#28a745'>{summary}</font>")

            self.refresh_condition_list_ui()
            
        except ValueError:
            QMessageBox.warning(self, "ì…ë ¥ ì˜¤ë¥˜", "ìˆ«ì í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.")
        except Exception as e:
             QMessageBox.critical(self, "ì˜¤ë¥˜", f"ì €ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")

    # [ë¯¸ì”½ ë©”ì„œë“œ ë³µêµ¬] í”„ë¡œí•„ ë²„íŠ¼ í´ë¦­ í•¸ë“¤ëŸ¬
    def on_profile_clicked(self, idx):
        # [ì‹ ê·œ] ë¡œë“œ ì „ ì‹œí€€ìŠ¤ ë²„íŠ¼ ìƒíƒœ ë°±ì—…
        is_seq_before_load = self.btn_seq_auto.isChecked()

        if self.is_save_mode:
            # ì €ì¥ ëª¨ë“œì¼ ë•Œ: í´ë¦­í•œ í”„ë¡œí•„ì— ì €ì¥
            self.save_settings(profile_idx=idx)
            self.stop_save_mode()
        else:
            # ì¼ë°˜ ëª¨ë“œì¼ ë•Œ: í”„ë¡œí•„ ë¡œë“œ (í˜„ì¬ ì‹œí€€ìŠ¤ ë²„íŠ¼ ìƒíƒœ ê°•ì œ ìœ ì§€)
            self.load_settings_to_ui(profile_idx=idx, keep_seq_auto=True)
            self.current_profile_idx = idx
            self.update_profile_buttons_ui()
            
            # [ìˆ˜ì •] ì‹œí€€ìŠ¤ ìë™ ëª¨ë“œ ì¡°ê±´ ê°•í™” (ê¸°ì¡´ì— ì´ë¯¸ ì¼œì ¸ ìˆì—ˆì„ ë•Œë§Œ ë¡œë“œ í›„ ìë™ ì‹œì‘)
            # ë¡œë“œëœ ì„¤ì •(target)ì— ì˜í•´ ì¼œì§€ëŠ” ê²½ìš°ì—ëŠ” ë°”ë¡œ ì‹œì‘í•˜ì§€ ì•ŠìŒ (ì‚¬ìš©ì í™•ì¸ ìš©ë„)
            if is_seq_before_load and self.btn_seq_auto.isChecked():
                self.append_log(f"ğŸš€ ì‹œí€€ìŠ¤ ìë™: í”„ë¡œí•„ {idx}ë²ˆ ì„ íƒë¨ - ì—”ì§„ì„ ìë™ ì‹œì‘í•©ë‹ˆë‹¤.")
                QTimer.singleShot(1000, self.on_start_clicked)

    # [ë¯¸ì”½ ë©”ì„œë“œ ë³µêµ¬] ì €ì¥ ëª¨ë“œ ì¢…ë£Œ
    def stop_save_mode(self):
        self.is_save_mode = False
        self.profile_blink_timer.stop()
        self.is_profile_blink_on = False
        
        # ë²„íŠ¼ ìŠ¤íƒ€ì¼ ë³µêµ¬
        self.btn_save.setStyleSheet("background-color: #6c757d; border-radius: 4px; color: white; border: 1px solid #5a6268; font-size: 20px;")
        self.update_profile_buttons_ui()

    # [ë¯¸ì”½ ë©”ì„œë“œ ë³µêµ¬] í”„ë¡œí•„ ë²„íŠ¼ UI ì—…ë°ì´íŠ¸ (ë°ì´í„° ìœ ë¬´ í‘œì‹œ)
    def update_profile_buttons_ui(self):
        try:
            settings = {}
            if os.path.exists(self.settings_file):
                with open(self.settings_file, 'r', encoding='utf-8') as f:
                    settings = json.load(f)
            
            profiles = settings.get('profiles', {})
            
            for i, btn in enumerate(self.profile_buttons):
                idx = i + 1
                has_data = str(idx) in profiles
                is_selected = (self.current_profile_idx == idx)
                
                # ê¸°ë³¸ ìŠ¤íƒ€ì¼
                base_style = "border-radius: 4px; font-weight: 900; padding: 0px; font-size: 16px; font-family: 'Arial';"
                
                if is_selected:
                    # ì„ íƒë¨: íŒŒë€ìƒ‰ í…Œë‘ë¦¬ ë˜ëŠ” ë°°ê²½
                    style = f"background-color: #e3f2fd; border: 2px solid #007bff; color: #007bff; {base_style}"
                elif has_data:
                    # ë°ì´í„° ìˆìŒ: íšŒìƒ‰ ë°°ê²½ (ì‚¬ìš©ì ìš”ì²­)
                    style = f"background-color: #cccccc; border: 1px solid #999; color: #333; {base_style}"
                else:
                    # ë¹„ì–´ìˆìŒ: í°ìƒ‰
                    style = f"background-color: #ffffff; border: 1px solid #ddd; color: #ccc; {base_style}"
                
                btn.setStyleSheet(style)
                    
        except Exception as e:
            self.append_log(f"UI ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")

    def on_save_button_clicked(self):
        """ì„¤ì • ì €ì¥ ë²„íŠ¼ í´ë¦­ ì‹œ: ì €ì¥ ëª¨ë“œ ì§„ì… ë° ì ë©¸ ì‹œì‘"""
        if not self.is_save_mode:
            self.is_save_mode = True
            self.profile_blink_timer.start()
            self.append_log("ğŸ’¡ ì €ì¥í•  ë²ˆí˜¸(1~3)ë¥¼ ì„ íƒí•˜ì„¸ìš”. (ë‹¤ì‹œ ëˆ„ë¥´ë©´ ì·¨ì†Œ)")
            self.btn_save.setStyleSheet("background-color: #ffc107; color: black; border-radius: 4px; font-weight: bold;")
        else:
            self.stop_save_mode()
            self.append_log("âŒ ì €ì¥ ëª¨ë“œê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")

    def on_seq_auto_toggled(self):
        """ì‹œí€€ìŠ¤ ìë™ ë²„íŠ¼ í† ê¸€ ì‹œ ì²˜ë¦¬"""
        is_on = self.btn_seq_auto.isChecked()
        if is_on:
            self.seq_blink_timer.start()
            self.append_log("ğŸ”„ ì‹œí€€ìŠ¤ ìë™ ëª¨ë“œ ON: ì¢…ë£Œ ì‹œê°„ ë„ë‹¬ ì‹œ ë‹¤ìŒ í”„ë¡œí•„ë¡œ ì „í™˜í•©ë‹ˆë‹¤.")
        else:
            self.seq_blink_timer.stop()
            self.btn_seq_auto.setStyleSheet("""
                QPushButton { background-color: #ffffff; border: 1px solid #999; border-radius: 4px; color: #ccc; font-size: 14px; font-weight: bold; }
            """)
            self.append_log("â¹ ì‹œí€€ìŠ¤ ìë™ ëª¨ë“œ OFF: ì¢…ë£Œ ì‹œê°„ ë„ë‹¬ ì‹œ ì•ŒëŒë§Œ ìš¸ë¦½ë‹ˆë‹¤.")
            self.is_seq_blink_on = False
        
        # [ì‹ ê·œ] ì‹œí€€ìŠ¤ ì‘ë™ ì¤‘ UI ì ê¸ˆ ì²˜ë¦¬
        self.lock_ui_for_sequence(is_on)

    def lock_ui_for_sequence(self, locked):
        """ì‹œí€€ìŠ¤ ìë™ ëª¨ë“œ í™œì„±í™” ì‹œ ì˜¤ì¡°ì‘ ë°©ì§€ë¥¼ ìœ„í•´ UI ì ê¸ˆ"""
        # ... (ìƒëµ) ...
        # [ìˆ˜ì •] READY ìƒíƒœì¼ ë•ŒëŠ” START ë²„íŠ¼ì„ ì ê·¸ì§€ ì•ŠìŒ (ì‚¬ìš©ìê°€ ì‹œì‘í•  ìˆ˜ ìˆë„ë¡)
        is_ready = "READY" in self.lbl_status.text()
        
        # ì…ë ¥ í•„ë“œ ë° ë²„íŠ¼ ì ê¸ˆ
        self.input_profit.setEnabled(not locked)
        self.input_loss.setEnabled(not locked)
        self.input_max.setEnabled(not locked)
        self.input_start_time.setEnabled(not locked)
        self.input_end_time.setEnabled(not locked)
        self.input_qty_val.setEnabled(not locked)
        self.input_amt_val.setEnabled(not locked)
        self.input_pct_val.setEnabled(not locked)
        
        for btn in self.cond_buttons: btn.setEnabled(not locked)
        for btn in self.profile_buttons: btn.setEnabled(not locked)
        self.btn_save.setEnabled(not locked)
        
        # START ë²„íŠ¼ì€ READY ìƒíƒœë©´ ì ê·¸ì§€ ì•ŠìŒ
        self.btn_start.setEnabled(not locked or is_ready)
        self.btn_stop.setEnabled(not locked) 
        
        if locked:
            self.append_log("ğŸ”’ UI ì ê¸ˆ: ì‹œí€€ìŠ¤ ì‘ë™ ì¤‘ì—ëŠ” ì„¤ì •ì„ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        else:
            self.append_log("ğŸ”“ UI ì ê¸ˆ í•´ì œ: ì„¤ì •ì„ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
            # [ìˆ˜ì •] ì ê¸ˆ í•´ì œ ì‹œ í˜„ì¬ ìƒíƒœ(RUNNING/READY)ì— ë§ì¶° ë²„íŠ¼ í™œì„±í™” ìƒíƒœ ë³µêµ¬
            current_status = self.lbl_status.text().replace("â— ", "").strip()
            self.update_status_ui(current_status)

    def blink_seq_button(self):
        """ì‹œí€€ìŠ¤ ë²„íŠ¼ ì ë©¸ íš¨ê³¼ (1ì´ˆ ë‹¨ìœ„)"""
        # ì²´í¬ëœ ìƒíƒœì—¬ì•¼ë§Œ ì ë©¸
        if not self.btn_seq_auto.isChecked():
            self.seq_blink_timer.stop()
            return

        self.is_seq_blink_on = not self.is_seq_blink_on
        if self.is_seq_blink_on:
            # ì¼œì§: ë…¹ìƒ‰ í…ìŠ¤íŠ¸ & ì•½ê°„ ì§„í•œ ë°°ê²½
            self.btn_seq_auto.setStyleSheet("""
                QPushButton { background-color: #e8f5e9; border: 2px solid #28a745; border-radius: 4px; color: #28a745; font-size: 14px; font-weight: bold; }
            """)
        else:
            # êº¼ì§: ê¸°ë³¸ ì²´í¬ ìƒíƒœ
            self.btn_seq_auto.setStyleSheet("""
                QPushButton { background-color: #e0e0e0; border: 1px solid #666; border-radius: 4px; color: #28a745; font-size: 14px; font-weight: bold; }
            """)

    def handle_end_time_event(self, current_time_str):
        """ì¢…ë£Œ ì‹œê°„ ë„ë‹¬ ì‹œ ì‹œí€€ìŠ¤ ë¡œì§ ì²˜ë¦¬"""
        # 1. ì‹œí€€ìŠ¤ ìë™ ëª¨ë“œì¸ì§€ í™•ì¸
        is_seq_auto = self.btn_seq_auto.isChecked() # [ìˆ˜ì •] ë²„íŠ¼ ìƒíƒœ í™•ì¸
        current_idx = self.current_profile_idx

        if is_seq_auto and current_idx is not None:
            # [ì‹œí€€ìŠ¤ ON] ë‹¤ìŒ í”„ë¡œí•„ë¡œ ì „í™˜ ì‹œë„
            next_idx = current_idx + 1
            if next_idx <= 3: # ìµœëŒ€ 3ë²ˆ í”„ë¡œí•„ê¹Œì§€ë§Œ
                # ë‹¤ìŒ í”„ë¡œí•„ ë°ì´í„° í™•ì¸
                try:
                    if os.path.exists(self.settings_file):
                        with open(self.settings_file, 'r', encoding='utf-8') as f:
                            settings = json.load(f)
                            if 'profiles' in settings and str(next_idx) in settings['profiles']:
                                self.append_log(f"ğŸ”„ ì‹œí€€ìŠ¤ ìë™: í”„ë¡œí•„ {current_idx}ë²ˆ ì¢…ë£Œ -> {next_idx}ë²ˆìœ¼ë¡œ ì „í™˜í•©ë‹ˆë‹¤.")
                                
                                # 1) í˜„ì¬ ì„¤ì • ì €ì¥
                                self.save_settings(profile_idx=current_idx, restart_if_running=False) # ì „í™˜ ì¤‘ ì¤‘ë³µ ì‹œì‘ ë°©ì§€
                                
                                # 2) ë‹¤ìŒ í”„ë¡œí•„ ë¡œë“œ (UIì™€ ë‚´ë¶€ ë³€ìˆ˜ ë™ê¸°í™”, ì‹œí€€ìŠ¤ ì˜¨ ìœ ì§€)
                                self.load_settings_to_ui(profile_idx=next_idx, keep_seq_auto=True)
                                
                                # 3) ì•ŒëŒ ë°œìƒ (ë‹¤ìŒ í”„ë¡œí•„ ì „í™˜ ì•Œë¦¼)
                                self.start_alarm(transition_to=next_idx)
                                
                                # 4) ì„¤ì • ì ìš© ë° ì—”ì§„ ì¬ê°€ë™ (API ì¬ë“±ë¡ ê°•ì œ ìˆ˜í–‰)
                                self.append_log("="*40)
                                self.append_log(f"ğŸ›°ï¸ [ì‹œí€€ìŠ¤] {next_idx}ë²ˆ í”„ë¡œí•„ë¡œ ì „í™˜: API ê²€ìƒ‰ì‹ ì¬ë“±ë¡ì„ ì‹œì‘í•©ë‹ˆë‹¤...")
                                self.append_log("="*40)
                                
                                # [ìˆ˜ì •] ì „í™˜ ì¤‘ ì¤‘ë³µ ì•ŒëŒ/ì´ë²¤íŠ¸ ë°©ì§€ë¥¼ ìœ„í•´ ì¦‰ì‹œ ì‹œê°„ ê¸°ë¡
                                self.last_alarm_time = current_time_str
                                
                                # [ìˆ˜ì •] ì‹œí€€ìŠ¤ ì „í™˜ ë”œë ˆì´ë¥¼ 1ì´ˆ -> 2.5ì´ˆë¡œ ì¦ê°€í•˜ì—¬ R10001 ì¤‘ë³µ ë¡œê·¸ì¸ ë°©ì§€
                                # ì´ì „ í”„ë¡œí•„ì˜ ì„¸ì…˜ì´ ì™„ì „íˆ ì •ë¦¬ë  ì‹œê°„ì„ í™•ë³´í•©ë‹ˆë‹¤.
                                QTimer.singleShot(2500, lambda: self.on_start_clicked(force=True)) 
                                return
                except Exception as e:
                    self.append_log(f"âš ï¸ ì‹œí€€ìŠ¤ ì „í™˜ ì¤‘ ì˜¤ë¥˜: {e}")

            # ë‹¤ìŒ í”„ë¡œí•„ì´ ì—†ê±°ë‚˜ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ (ìµœì¢… ì‹œí€€ìŠ¤ ì¢…ë£Œ)
            self.append_log("ğŸ ì‹œí€€ìŠ¤ ì¢…ë£Œ: ëª¨ë“  í”„ë¡œí•„ ë‹¨ê³„ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
            
            # ì‹œí€€ìŠ¤ ì¢…ë£Œ ì‹œ ë²„íŠ¼ ë„ê¸° ë° UI ì ê¸ˆ í•´ì œ
            self.btn_seq_auto.setChecked(False)
            self.on_seq_auto_toggled() 
            
            # [ì¶”ê°€] UI ì™„ì „ ì´ˆê¸°í™” ë° ë²„íŠ¼ ìƒíƒœ ë³µêµ¬
            self.lock_ui_for_sequence(False)
            self.update_status_ui("READY")
            self.append_log("ğŸ”“ ì‹œí€€ìŠ¤ ì¢…ë£Œ: ëª¨ë“  UI ì¡°ì‘ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.")
            
            self.start_alarm() # ë§ˆì§€ë§‰ ì¢…ë£Œ ì•ŒëŒ
            self.worker.schedule_command('stop') # ë§¤ë§¤ ì¤‘ë‹¨
            
            # [ìˆ˜ì •] ì¤‘ë‹¨ í›„ ì•½ê°„ì˜ ì—¬ìœ ë¥¼ ë‘ê³  ìµœì¢… ë³´ê³  ì „ì†¡ (workerì— today ì¶”ê°€ë¨)
            QTimer.singleShot(2500, lambda: self.worker.schedule_command('today'))
            return

        # [ì‹œí€€ìŠ¤ OFF]
        self.start_alarm(just_sound=True)

    def start_alarm(self, just_sound=False, transition_to=None):
        # ... (ê¸°ì¡´ start_alarm ë¡œì§) ...
        if self.alarm_playing:
            return
            
        try:
            self.alarm_playing = True
            
            # ë²„íŠ¼ ìƒíƒœ ë³€ê²½
            self.btn_alarm_stop.setEnabled(True)
            self.btn_alarm_stop.setText("ğŸ””") 
            self.blink_timer.start() # ê¹œë¹¡ì„ ì‹œì‘
            
            if transition_to:
                log_msg = f"ğŸ”„ ì‹œí€€ìŠ¤ ì „í™˜: {transition_to}ë²ˆ í”„ë¡œí•„ë¡œ ì´ë™í•©ë‹ˆë‹¤. (ë§¤ë§¤ ê³„ì†)"
            elif just_sound:
                log_msg = f"â° ì¢…ë£Œ ì‹œê°„({self.input_end_time.text()}) ë„ë‹¬! (ë§¤ë§¤ëŠ” ê³„ì†ë©ë‹ˆë‹¤)"
            else:
                log_msg = f"â° ì•ŒëŒ ë°œìƒ: ì¢…ë£Œ ì‹œê°„({self.input_end_time.text()}) ë„ë‹¬!"
                
            self.append_log(log_msg)
            
            sound_path = os.path.join(self.script_dir, "StockAlarm.wav")
            if os.path.exists(sound_path):
                winsound.PlaySound(sound_path, winsound.SND_FILENAME | winsound.SND_ASYNC | winsound.SND_LOOP)
            else:
                self.append_log(f"âš ï¸ ì•ŒëŒ íŒŒì¼ ì—†ìŒ: {sound_path}")
            
        except Exception as e:
            self.append_log(f"âš ï¸ ì•ŒëŒ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {e}")
            self.alarm_playing = False


    def closeEvent(self, event):
        reply = QMessageBox.question(self, 'ì¢…ë£Œ', 'í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?',
                                   QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, 
                                   QMessageBox.StandardButton.No)

        if reply == QMessageBox.StandardButton.Yes:
            self.worker.stop()
            event.accept()
        else:
            event.ignore()

    def toggle_profile_blink(self):
        """ì €ì¥ ëª¨ë“œ ì‹œ ë²ˆí˜¸ ë²„íŠ¼ ì ë©¸ íš¨ê³¼"""
        self.is_profile_blink_on = not self.is_profile_blink_on
        color = "#ffc107" if self.is_profile_blink_on else "#f8f9fa"
        for btn in self.profile_buttons:
            btn.setStyleSheet(f"background-color: {color}; border: 2px solid #ffc107; border-radius: 4px; font-weight: bold; color: black; padding: 0px; font-size: 14px;")

    # [ë³µêµ¬] í•­ìƒ ìœ„ í† ê¸€ ë©”ì„œë“œ
    def toggle_always_on_top(self, checked):
        if checked:
            self.setWindowFlag(Qt.WindowType.WindowStaysOnTopHint, True)
            self.show()
        else:
            self.setWindowFlag(Qt.WindowType.WindowStaysOnTopHint, False)
            self.show()

if __name__ == '__main__':
    try:
        # [ì¶”ê°€] Windows ì‘ì—…í‘œì‹œì¤„ ì•„ì´ì½˜ ê³ ì • ë° í‘œì‹œë¥¼ ìœ„í•œ ID ì„¤ì •
        if sys.platform == 'win32':
            import ctypes
            myappid = 'kipo.buy.auto.4.2'
            ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)

        app = QApplication(sys.argv)
        
        # Font Setup
        font = QFont("Malgun Gothic", 9)
        app.setFont(font)
        
        window = KipoWindow()
        window.show()
        
        retCode = app.exec()
        sys.exit(retCode)
        
    except BaseException as e:
        # BaseExceptionì„ í†µí•´ SystemExitê¹Œì§€ ëª¨ë‘ ìº¡ì²˜
        with open("crash_report.txt", "a", encoding="utf-8") as f:
            f.write(f"\n[{datetime.datetime.now()}] CRASH/EXIT LOGGED:\n")
            f.write(traceback.format_exc())
            f.write(f"Error Type: {type(e)}\n")
            f.write("-" * 50 + "\n")
        
        if not isinstance(e, SystemExit):
            # [ìˆ˜ì •] GUI ì•±ì´ë¯€ë¡œ ì½˜ì†” ì…ë ¥(input) ì œê±° + ë©”ì‹œì§€ ë°•ìŠ¤ ì‹œë„
            # Qt ì•±ì´ ì‚´ì•„ìˆë‹¤ë©´ ë©”ì‹œì§€ë°•ìŠ¤ë¥¼ ë„ìš°ì§€ë§Œ, ì£½ì—ˆì„ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ ì•ˆì „í•˜ê²Œ íŒ¨ìŠ¤ í˜¹ì€ windows api ì‚¬ìš©
            try:
                import ctypes
                ctypes.windll.user32.MessageBoxW(0, f"Critical Error: {e}\nSee crash_report.txt", "Error", 0x10)
            except:
                pass
===


import sys
import os
import asyncio
import json
import datetime
import traceback
import ast
import requests
from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                           QHBoxLayout, QLabel, QLineEdit, QPushButton, 
                           QTextEdit, QFrame, QGridLayout, QMessageBox, QGroupBox,
                           QScrollArea, QRadioButton, QButtonGroup, QCheckBox)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QObject, QTimer
from PyQt6.QtGui import QFont, QIcon, QColor, QPalette
import winsound

# ê¸°ì¡´ ëª¨ë“ˆ ì„í¬íŠ¸

# ê¸°ì¡´ ëª¨ë“ˆ ì„í¬íŠ¸
from config import telegram_token
from chat_command import ChatCommand
from get_setting import get_setting, cached_setting
from market_hour import MarketHour

# ----------------- Worker Thread for Asyncio Loop -----------------
class WorkerSignals(QObject):
    log_signal = pyqtSignal(str)
    status_signal = pyqtSignal(str)  # ìƒíƒœ í‘œì‹œì¤„ ì—…ë°ì´íŠ¸ìš©
    clr_signal = pyqtSignal()       # [ì‹ ê·œ] ë¡œê·¸ ì´ˆê¸°í™”ìš©
    request_log_signal = pyqtSignal() # [ì‹ ê·œ] ë¡œê·¸ íŒŒì¼ ì¶œë ¥ ìš”ì²­

class AsyncWorker(QThread):
    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self.signals = WorkerSignals()
        self.loop = None
        self.chat_command = None
        self.keep_running = True
        self.pending_start = False # [ì¶”ê°€] ì¥ì™¸ ì‹œê°„ ì˜ˆì•½ ì‹œì‘ ê¸°ëŠ¥ìš©
        self.pending_profile_info = None

    def run(self):
        # Create a new event loop for this thread
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)
        
        # 1. Override tel_send logic
        import chat_command as chat_cmd_module
        
        def gui_log_send(text):
            self.signals.log_signal.emit(text)
        
        # Patch tel_send in chat_command
        chat_cmd_module.tel_send = gui_log_send
        
        # 2. Redirect stdout/stderr to capture prints from get_seq.py and others
        class StreamRedirector:
            def __init__(self, emitter):
                self.emitter = emitter
            def write(self, text):
                text = text.strip()
                if text:
                    self.emitter(text)
            def flush(self):
                pass
                
        sys.stdout = StreamRedirector(gui_log_send)
        sys.stderr = StreamRedirector(gui_log_send)

        # Initialize ChatCommand
        self.chat_command = ChatCommand()
        self.chat_command.on_clear_logs = lambda: self.signals.clr_signal.emit()
        self.chat_command.on_request_log_file = lambda: self.signals.request_log_signal.emit()
        self.chat_command.rt_search.on_connection_closed = self._on_connection_closed_wrapper
        
        self.loop.run_until_complete(self.main_loop())
        self.loop.close()

    async def _on_connection_closed_wrapper(self):
        self.signals.log_signal.emit("âš ï¸ ì—°ê²° ëŠê¹€ ê°ì§€. ì¬ì—°ê²° ì‹œë„ ì¤‘...")
        await self.chat_command._on_connection_closed()

    async def main_loop(self):
        self.signals.log_signal.emit("ğŸš€ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ. ëŒ€ê¸° ì¤‘...")
        
        # ì„¤ì • ë¡œë“œ ë° ì ìš©
        self.load_initial_settings()
        
        # ì‹œì‘ ì‹œ ìë™ìœ¼ë¡œ ì¡°ê±´ì‹ ëª©ë¡ ê°€ì ¸ì˜¤ê¸° (ë§ˆì§€ë§‰ ì €ì¥ëœ ì„¤ì •ëŒ€ë¡œ í•„í„°ë§ë˜ì–´ í‘œì‹œë¨)
        self.signals.log_signal.emit("â„¹ï¸ ì €ì¥ëœ ì¡°ê±´ì‹ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤...")
        await self.chat_command.condition()
        
        # [ì¶”ê°€] ìë™ ì‹œì‘(auto_start) ì„¤ì • í™•ì¸ ë° ì‹¤í–‰
        try:
            settings_path = os.path.join(os.path.dirname(sys.executable) if getattr(sys, 'frozen', False) else os.path.dirname(os.path.abspath(__file__)), 'settings.json')
            if os.path.exists(settings_path):
                with open(settings_path, 'r', encoding='utf-8') as f:
                    settings = json.load(f)
                
                if settings.get('auto_start', False):
                    self.signals.log_signal.emit("â„¹ï¸ ìë™ ì‹œì‘ ì„¤ì •ì´ í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.")
                    # ì•½ê°„ì˜ ë”œë ˆì´ í›„ ì‹œì‘ ì‹œë„ (ì´ˆê¸°í™” ì•ˆì •ì„± í™•ë³´)
                    await asyncio.sleep(1.0)
                    # ì§ì ‘ await í˜¸ì¶œ (ê°™ì€ ë£¨í”„ ë‚´ì´ë¯€ë¡œ schedule_command ëŒ€ì‹  ì§ì ‘ í˜¸ì¶œ)
                    await self._execute_command('start')
        except Exception as e:
            self.signals.log_signal.emit(f"âš ï¸ ìë™ ì‹œì‘ í™•ì¸ ì¤‘ ì˜¤ë¥˜: {e}")
        
        try:
            while self.keep_running:
                # í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ í™•ì¸ (GUIì—ì„œëŠ” í•„ìˆ˜ ì•„ë‹˜, í…”ë ˆê·¸ë¨ ì œì–´ ì›í•  ì‹œ ìœ ì§€)
                message = self.get_chat_updates()
                if message:
                    await self.chat_command.process_command(message)
                
                
                # [ì¶”ê°€] ì¥ ì¢…ë£Œ ì‹œ ìë™ ì¤‘ë‹¨ ë° ë³´ê³  ì‹œí€€ìŠ¤ (15:30)
                now = datetime.datetime.now()
                if now.hour == 15 and now.minute == 30 and not self.today_stopped:
                    self.today_stopped = True
                    self.signals.log_signal.emit("ğŸ”” ì¥ ì¢…ë£Œ ì‹œê°„(15:30)ì´ ë˜ì–´ ìë™ìœ¼ë¡œ ì •ì‚° ì‹œí€€ìŠ¤ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.")
                    
                    # 1. ì¤‘ì§€ (STOP)
                    await self.chat_command.stop(set_auto_start_false=False)
                    # 2. ë‹¹ì¼ ì¼ì§€ (TODAY)
                    await self.chat_command.today()
                    # 3. ê³„ì¢Œ ë³´ê³  (REPORT)
                    await self.chat_command.report()

                # ë‚ ì§œê°€ ë°”ë€Œë©´ ì¢…ë£Œ í”Œë˜ê·¸ ì´ˆê¸°í™”
                current_date = now.date()
                if self.last_check_date != current_date:
                    self.last_check_date = current_date
                    self.today_stopped = False

                # ì¥ ì‹œì‘/ì¢…ë£Œ ì‹œê°„ ìë™ í™•ì¸ ë¡œì§
                # [ìˆ˜ì •] ëŒ€ê¸° ì‹œê°„(is_waiting_period)ì´ ì•„ë‹ ë•Œë§Œ ìë™ ì‹œì‘ ì§„í–‰í•˜ì—¬ ë¬´í•œ ë£¨í”„ ë°©ì§€
                if self.pending_start and MarketHour.is_market_open_time() and not MarketHour.is_waiting_period():
                    self.pending_start = False
                    self.signals.log_signal.emit("ğŸ”” ì¥ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤. ê°ì‹œë¥¼ ìë™ìœ¼ë¡œ ì‹œì‘í•©ë‹ˆë‹¤!")
                    self.schedule_command('start', getattr(self, 'pending_profile_info', None))
                
                await asyncio.sleep(1.0) # ì²´í¬ ì£¼ê¸° ì¡°ì •
                
        except Exception as e:
            self.signals.log_signal.emit(f"âŒ ë©”ì¸ ë£¨í”„ ì—ëŸ¬: {e}")

    def load_initial_settings(self):
        try:
            with open('settings.json', 'r', encoding='utf-8') as f:
                settings = json.load(f)
                
            # ì‹œê°„ ì„¤ì • ì ìš© (settings.jsonì— ì‹œê°„ì´ ì—†ë‹¤ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©)
            start_time = settings.get('start_time', "09:00")
            end_time = settings.get('end_time', "15:20") # ì¥ ì¢…ë£Œ 10ë¶„ì „
            
            sh, sm = map(int, start_time.split(':'))
            eh, em = map(int, end_time.split(':'))
            
            MarketHour.set_market_hours(sh, sm, eh, em)
            self.signals.log_signal.emit(f"âš™ï¸ ì¥ ìš´ì˜ ì‹œê°„ ì„¤ì •: {start_time} ~ {end_time}")
            
        except Exception as e:
            self.signals.log_signal.emit(f"âš ï¸ ì„¤ì • ë¡œë“œ ì¤‘ ì˜¤ë¥˜ (ê¸°ë³¸ê°’ ì‚¬ìš©): {e}")

    # MainAppì˜ ë¡œì§ ê°€ì ¸ì˜´
    last_update_id = 0
    telegram_url = f"https://api.telegram.org/bot{telegram_token}/getUpdates"
    today_started = False
    today_stopped = False
    last_check_date = None

    def get_chat_updates(self):
        """í…”ë ˆê·¸ë¨ì—ì„œ ìƒˆë¡œìš´ ëª…ë ¹ì–´ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤."""
        try:
            params = {'offset': self.last_update_id + 1, 'timeout': 1}
            response = requests.get(self.telegram_url, params=params, timeout=5)
            if response.status_code == 200:
                data = response.json()
                for update in data.get('result', []):
                    self.last_update_id = update['update_id']
                    if 'message' in update and 'text' in update['message']:
                        chat_id = str(update['message']['chat']['id'])
                        
                        # [ë³´ì•ˆ] ì„¤ì •ëœ chat_idì™€ ì¼ì¹˜í•  ë•Œë§Œ ì‹¤í–‰
                        from config import telegram_chat_id
                        if chat_id == telegram_chat_id:
                            return update['message']['text']
                        else:
                            print(f"âš ï¸ ê¶Œí•œ ì—†ëŠ” ì‚¬ìš©ì ì ‘ê·¼ ì°¨ë‹¨ (ID: {chat_id})")
        except Exception as e:
            # Polling ì—ëŸ¬ëŠ” ë¡œê·¸ì—ë§Œ ê°„ë‹¨íˆ ê¸°ë¡
            pass
        return None
            
    # check_market_timing ë©”ì„œë“œ ì œê±° (ìë™ ì¢…ë£Œ ì¶©ëŒ ë°©ì§€)

    # GUIì—ì„œ í˜¸ì¶œí•  ë¹„ë™ê¸° ëª…ë ¹ë“¤
    def schedule_command(self, cmd_type, *args):
        asyncio.run_coroutine_threadsafe(self._execute_command(cmd_type, *args), self.loop)

    async def _execute_command(self, cmd_type, *args):
        try:
            if cmd_type == 'start':
                # [ìˆ˜ì •] ì¥ì™¸ ì‹œê°„ ì˜ˆì•½ ì‹œì‘ ì²˜ë¦¬ (ì‚¬ìš©ì ìš”ì²­: 15:30 ~ 09:00 ì‚¬ì´ë§Œ WAITING ì²˜ë¦¬)
                # ë‚® ì‹œê°„(09~15:30) ì¤‘ì— ì‚¬ìš©ì ì¢…ë£Œ ì„¤ì • ë“±ìœ¼ë¡œ ì‹œì‘ì´ ì•ˆë˜ëŠ” ê²½ìš°ëŠ” READY ìœ ì§€
                if MarketHour.is_waiting_period():
                    if not self.pending_start:
                        self.pending_start = True
                        self.pending_profile_info = args[0] if args else None
                        
                        # [ìˆ˜ì •] ì•ˆë‚´ ë©”ì‹œì§€ì— ì‹¤ì œ ì„¤ì •ëœ ì‹œê°„ í‘œì‹œ (main_window ìœ„ì ¯ ì ‘ê·¼ ìˆ˜ì •)
                        st_str = self.main_window.input_start_time.text()
                        et_str = self.main_window.input_end_time.text()
                        self.signals.log_signal.emit(f"â³ í˜„ì¬ ì¥ì™¸ ëŒ€ê¸° ì‹œê°„ì…ë‹ˆë‹¤. ({st_str}~{et_str})")
                        self.signals.log_signal.emit("âŒ› ì¥ì´ ì‹œì‘ë˜ë©´ ìë™ìœ¼ë¡œ ê°ì‹œë¥¼ ê°œì‹œí•˜ê² ìŠµë‹ˆë‹¤.")
                        self.signals.status_signal.emit("WAITING")
                    return
                
                # ë‚® ì‹œê°„ì¸ë° ì‹œì‘ ì‹œë„
                profile_info = args[0] if args else None
                success = await self.chat_command.start(profile_info=profile_info)
                if success:
                    self.pending_start = False
                    self.signals.status_signal.emit("RUNNING")
                else:
                    self.signals.status_signal.emit("READY")
                    self.signals.log_signal.emit("âš ï¸ ì¥ ì‹œì‘ ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì‹œê°„ ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.")
                    # [ì‹ ê·œ] ì¥ì™¸ ì‹œê°„ ë“± ì‹œì‘ ì‹¤íŒ¨ ì‹œ ê²½ê³ ìŒ
                    try:
                        import winsound
                        winsound.MessageBeep(winsound.MB_ICONEXCLAMATION)
                    except: pass
                return
            elif cmd_type == 'stop':
                self.pending_start = False # ì˜ˆì•½ ì·¨ì†Œ
                await self.chat_command.stop(True)
                self.signals.status_signal.emit("READY")
            elif cmd_type == 'report':
                await self.chat_command.report()
            elif cmd_type == 'custom':
                await self.chat_command.process_command(args[0])
            elif cmd_type == 'update_setting':
                # settings.json ì—…ë°ì´íŠ¸
                self.chat_command.update_setting(args[0], args[1])
                self.signals.log_signal.emit(f"âœ… ì„¤ì • ë³€ê²½: {args[0]} = {args[1]}")
                
            elif cmd_type == 'update_settings':
                # [ì‹ ê·œ] ì—¬ëŸ¬ ì„¤ì •ì„ í•œ ë²ˆì— ì—…ë°ì´íŠ¸
                updates = args[0]
                quiet = args[1] if len(args) > 1 else False
                self.chat_command.update_settings_batch(updates)
                if not quiet:
                    self.signals.log_signal.emit("âœ… ì¼ê´„ ì„¤ì • ì €ì¥ ì™„ë£Œ")
                
            elif cmd_type == 'today':
                await self.chat_command.today()
                
            elif cmd_type == 'condition_list':
                quiet = args[0] if args else False
                await self.chat_command.condition(quiet=quiet) # quiet ì¸ì ì „ë‹¬

        except Exception as e:
            self.signals.log_signal.emit(f"âŒ ëª…ë ¹ ì‹¤í–‰ ì˜¤ë¥˜: {e}")

    def stop(self):
        """ì•ˆì „í•œ ì¢…ë£Œ ì²˜ë¦¬"""
        self.keep_running = False
        if self.loop and self.loop.is_running():
             # ë£¨í”„ ë‚´ì—ì„œ ì •ë¦¬ ì‘ì—… ìˆ˜í–‰ í›„ ì¢…ë£Œ
             self.loop.call_soon_threadsafe(lambda: asyncio.create_task(self.shutdown()))
        
        # ìŠ¤ë ˆë“œ ì¢…ë£Œ ëŒ€ê¸° (ìµœëŒ€ 3ì´ˆ)
        self.wait(3000)

    async def shutdown(self):
        """ë¹„ë™ê¸° ë¦¬ì†ŒìŠ¤ ì •ë¦¬"""
        if self.chat_command:
            await self.chat_command.stop(True)
        # ë£¨í”„ ì •ì§€ (pending task cancelì€ ìƒëµí•¨)
        self.loop.stop()


# ----------------- Main Window -----------------
class KipoWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("ğŸš€ KipoBuy Auto Trading System - V5.3.9 (Automation Edition)")
        # íŒŒì¼ ê²½ë¡œ ì„¤ì • (ì¤‘ìš”: ë¦¬ì†ŒìŠ¤ì™€ ì„¤ì • íŒŒì¼ ë¶„ë¦¬)
        if getattr(sys, 'frozen', False):
            # ì‹¤í–‰ íŒŒì¼ ìœ„ì¹˜ (settings.json, ë¡œê·¸ ì €ì¥ìš©)
            self.script_dir = os.path.dirname(sys.executable)
            # ì„ì‹œ ë¦¬ì†ŒìŠ¤ ìœ„ì¹˜ (ì•„ì´ì½˜ ë“± ë²ˆë“¤ëœ íŒŒì¼ìš©)
            self.resource_dir = sys._MEIPASS
        else:
            self.script_dir = os.path.dirname(os.path.abspath(__file__))
            self.resource_dir = self.script_dir
            
        self.settings_file = os.path.join(self.script_dir, 'settings.json')

        # ì•„ì´ì½˜ ì„¤ì • (ë¦¬ì†ŒìŠ¤ ê²½ë¡œì—ì„œ ë¡œë“œ)
        icon_path = os.path.join(self.resource_dir, 'icon.png')
        icon_path_ico = os.path.join(self.resource_dir, 'icon.ico')
        
        if os.path.exists(icon_path):
            self.setWindowIcon(QIcon(icon_path))
        elif os.path.exists(icon_path_ico):
            self.setWindowIcon(QIcon(icon_path_ico))
        else:
            # Fallback checks in script directory
            for ext in ['png', 'ico']:
                p = os.path.join(self.script_dir, f'icon.{ext}')
                if os.path.exists(p):
                    self.setWindowIcon(QIcon(p))
                    break
                
        self.resize(1000, 700)
        
        self.setup_ui()
        self.setup_worker()
        self.load_settings_to_ui()

        # ì•ŒëŒ ê´€ë ¨ ì´ˆê¸°í™”
        self.alarm_playing = False
        self.last_alarm_time = None # ì´ì „ ì•ŒëŒ ë°œìƒ ì‹œê°„ (ì¤‘ë³µ ë°œìƒ ë°©ì§€)
        self.app_start_time = datetime.datetime.now() # ì‹œì‘ ì‹œê°„ ê¸°ë¡ (ì•ˆì „ì¥ì¹˜)
        self.last_auto_start_time = None # [ì‹ ê·œ] ì‹œì‘ ì•ŒëŒ ì¤‘ë³µ ë°©ì§€ìš©

        # ì•ŒëŒ ë°˜ë³µ íƒ€ì´ë¨¸ ì œê±° (ì†Œë¦¬ ê¸°ëŠ¥ ì™„ì „ ë¹„í™œì„±í™”)
        # self.sound_repeater = QTimer(self)
        
        self.alarm_timer = QTimer(self)
        self.alarm_timer.setInterval(1000) # 1ì´ˆë§ˆë‹¤ ì²´í¬
        self.alarm_timer.timeout.connect(self.check_alarm)
        self.alarm_timer.start()

        # ì•ŒëŒ ë²„íŠ¼ ê¹œë¹¡ì„ íƒ€ì´ë¨¸
        self.blink_timer = QTimer(self)
        self.blink_timer.setInterval(500) # 0.5ì´ˆë§ˆë‹¤ ë°˜ì „
        self.blink_timer.timeout.connect(self.toggle_blink)
        self.is_blink_on = False

        # í”„ë¡œí•„ ê´€ë ¨ ì´ˆê¸°í™”
        self.is_save_mode = False
        self.profile_blink_timer = QTimer(self)
        self.profile_blink_timer.setInterval(400) # ì ë©¸ ì†ë„
        self.profile_blink_timer.timeout.connect(self.toggle_profile_blink)
        self.is_profile_blink_on = False
        self.current_profile_idx = None # í˜„ì¬ ì„ íƒëœ í”„ë¡œí•„ ì¸ë±ìŠ¤

    def setup_ui(self):
        # --- Styles ---
        self.setStyleSheet("""
            QMainWindow { background-color: #f0f2f5; }
            QGroupBox { font-weight: bold; border: 1px solid #ccc; border-radius: 8px; margin-top: 10px; padding-top: 15px; background-color: white; }
            QGroupBox::title { subcontrol-origin: margin; subcontrol-position: top left; left: 10px; padding: 0 5px; }
            QLabel { color: #333; }
            QLineEdit { padding: 5px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9; }
            
            /* ë²„íŠ¼ ìŠ¤íƒ€ì¼ì„ íŠ¹ì • í´ë˜ìŠ¤ë¡œ ì œí•œí•˜ê±°ë‚˜ QMessageBox ë²„íŠ¼ì„ ìœ„í•œ ì˜ˆì™¸ ì²˜ë¦¬ */
            QPushButton { padding: 8px 15px; border-radius: 5px; font-weight: bold; color: white; border: none; }
            QPushButton:hover { opacity: 0.9; }
            
            /* QMessageBox ë²„íŠ¼ ë³µêµ¬ */
            QMessageBox QPushButton {
                background-color: #007bff; /* íŒŒë€ìƒ‰ */
                color: white;
                border: 1px solid #0056b3;
                min-width: 60px;
            }
            QMessageBox QPushButton:hover {
                background-color: #0056b3;
            }
            
            QTextEdit { background-color: #1e1e1e; color: #00ff00; font-family: 'Consolas', 'Monospace'; border-radius: 5px; padding: 10px; }
        """)

        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        # Root Layout: Vertical (Header + Body)
        root_layout = QVBoxLayout(central_widget)
        root_layout.setContentsMargins(10, 10, 10, 10)
        root_layout.setSpacing(10)

        # === 0. Global Header ===
        header_widget = QWidget()
        header_layout = QHBoxLayout(header_widget)
        header_layout.setContentsMargins(0, 0, 0, 10)
        
        # Spacer to balance
        left_spacer = QWidget()
        left_spacer.setFixedWidth(40) 
        
        self.lbl_main_title = QLabel("ğŸš€ KipoStock V5.1 (Stable)")
        self.lbl_main_title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.lbl_main_title.setFont(QFont("Arial", 20, QFont.Weight.Bold))
        self.lbl_main_title.setStyleSheet("color: #2c3e50;")

        # [ì‹ ê·œ] ìƒíƒœ í‘œì‹œë“± (READY / RUNNING)
        self.lbl_status = QLabel("â— READY")
        self.lbl_status.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        self.lbl_status.setStyleSheet("color: #6c757d; margin-left: 10px;")

        # [ì‹ ê·œ] í˜„ì¬ ì‹œê°„ í‘œì‹œ ì‹œê³„
        self.lbl_clock = QLabel(datetime.datetime.now().strftime("%H:%M:%S"))
        self.lbl_clock.setFont(QFont("Arial", 12, QFont.Weight.Bold))
        self.lbl_clock.setStyleSheet("color: #2c3e50; margin-left: 10px;")
        
        # Always on Top Button (Pin icon)
        self.btn_top = QPushButton("ğŸ“")
        self.btn_top.setCheckable(True)
        self.btn_top.setFixedSize(40, 40)
        self.btn_top.setToolTip("í•­ìƒ ìœ„ì— ê³ ì •")
        self.btn_top.setStyleSheet("""
            QPushButton { background-color: #f8f9fa; border-radius: 5px; font-size: 18px; border: 1px solid #ddd; color: #aaa; }
            QPushButton:checked { background-color: #17a2b8; color: white; border: 1px solid #138496; }
            QPushButton:hover { background-color: #e2e6ea; }
        """)
        self.btn_top.clicked.connect(self.toggle_always_on_top)
        
        header_layout.addWidget(left_spacer)
        header_layout.addStretch()
        header_layout.addWidget(self.lbl_main_title)
        header_layout.addWidget(self.lbl_status)
        header_layout.addWidget(self.lbl_clock)
        header_layout.addStretch()
        header_layout.addWidget(self.btn_top)
        
        root_layout.addWidget(header_widget)

        # === Body Layout (Left + Right) ===
        body_layout = QHBoxLayout()
        body_layout.setContentsMargins(0, 0, 0, 0)
        body_layout.setSpacing(10)
        root_layout.addLayout(body_layout)

        # === Left Panel: Settings ===
        left_panel = QFrame()
        left_panel.setFixedWidth(280)
        left_layout = QVBoxLayout(left_panel)
        left_layout.setContentsMargins(0, 0, 0, 0)
        
        # 1. Settings Group
        settings_group = QGroupBox("âš™ï¸ Settings")
        settings_layout = QVBoxLayout()
        settings_layout.setSpacing(12)

        # Condition Select (0-19) - 4 State Buttons
        cond_label = QLabel("ì¡°ê±´ì‹ ì„ íƒ (0-19)")
        self.cond_btn_layout = QGridLayout() # [ìˆ˜ì •] Grid Layout ì‚¬ìš©
        self.cond_btn_layout.setSpacing(2)
        self.cond_buttons = []
        # State: 0 (Gray/Off), 1 (Red/Qty), 2 (Green/Amt), 3 (Blue/Pct)
        self.cond_states = [0] * 20 # [ìˆ˜ì •] 20ê°œë¡œ í™•ì¥
        
        for i in range(20):
            btn = QPushButton(str(i))
            btn.setFixedSize(22, 22)
            btn.setStyleSheet("background-color: #e0e0e0; color: #333; font-weight: bold; border-radius: 4px;")
            btn.clicked.connect(lambda checked, idx=i: self.on_cond_clicked(idx))
            self.cond_buttons.append(btn)
            # 2ì¤„ë¡œ ë°°ì¹˜ (0~9: 1ì—´, 10~19: 2ì—´) -> 10ê°œì”© ëŠì–´ì„œ ë°°ì¹˜
            row = i // 10
            col = i % 10
            self.cond_btn_layout.addWidget(btn, row, col)
        
        settings_layout.addWidget(cond_label)
        settings_layout.addLayout(self.cond_btn_layout)

        # Profit, Loss & Max Stocks (Horizontal)
        top_settings_layout = QHBoxLayout()
        
        # Profit
        top_settings_layout.addWidget(QLabel("ìµì ˆ"))
        self.input_profit = QLineEdit()
        self.input_profit.setFixedWidth(45)
        self.input_profit.setStyleSheet("border: 2px solid #dc3545; border-radius: 4px; padding: 3px; font-weight: bold;")
        top_settings_layout.addWidget(self.input_profit)
        
        top_settings_layout.addSpacing(5)
        
        # Loss
        top_settings_layout.addWidget(QLabel("ì†ì ˆ"))
        self.input_loss = QLineEdit()
        self.input_loss.setFixedWidth(45)
        self.input_loss.setStyleSheet("border: 2px solid #007bff; border-radius: 4px; padding: 3px; font-weight: bold;")
        top_settings_layout.addWidget(self.input_loss)

        top_settings_layout.addSpacing(5)

        # Max Stocks (Shortened label for horizontal fit)
        top_settings_layout.addWidget(QLabel("ì¢…ëª©ìˆ˜"))
        self.input_max = QLineEdit()
        self.input_max.setFixedWidth(35)
        self.input_max.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.input_max.setStyleSheet("border: 2px solid black; border-radius: 4px; padding: 3px; font-weight: bold;")
        top_settings_layout.addWidget(self.input_max)
        
        top_settings_layout.addStretch()
        settings_layout.addLayout(top_settings_layout)

        # Time Settings (Horizontal)
        time_layout = QHBoxLayout()
        
        # Start
        time_layout.addWidget(QLabel("ì‹œì‘"))
        self.input_start_time = QLineEdit()
        self.input_start_time.setFixedWidth(50)
        self.input_start_time.setAlignment(Qt.AlignmentFlag.AlignCenter)
        time_layout.addWidget(self.input_start_time)
        
        time_layout.addSpacing(5)
        
        # End
        time_layout.addWidget(QLabel("ì¢…ë£Œ"))
        self.input_end_time = QLineEdit()
        self.input_end_time.setFixedWidth(50)
        self.input_end_time.setAlignment(Qt.AlignmentFlag.AlignCenter)
        time_layout.addWidget(self.input_end_time)
        
        # ğŸ”” ì•ŒëŒ í•´ì œ ë²„íŠ¼
        self.btn_alarm_stop = QPushButton("ğŸ”•")
        self.btn_alarm_stop.setToolTip("ì•ŒëŒ í•´ì œ")
        self.btn_alarm_stop.setFixedWidth(40)
        self.btn_alarm_stop.setFixedHeight(30)
        self.btn_alarm_stop.clicked.connect(self.stop_alarm)
        self.btn_alarm_stop.setEnabled(False)
        self.btn_alarm_stop.setStyleSheet("""
            QPushButton {
                background-color: #f8f9fa;
                border: 1px solid #ddd;
                border-radius: 4px;
                font-size: 16px;
                color: #aaa;
            }
            QPushButton:enabled {
                background-color: #ffc107; /* ì¢… ëª¨ì–‘ì´ ìš¸ë¦´ ë•ŒëŠ” ë…¸ë€ìƒ‰ */
                color: #000;
                border: 1px solid #e0a800;
            }
        """)
        time_layout.addSpacing(10)
        time_layout.addWidget(self.btn_alarm_stop)
        time_layout.addStretch()
        settings_layout.addLayout(time_layout)

        # ğŸ’ Buying Strategy Group (Revised for Color Matching)
        strategy_group = QGroupBox("ğŸ’ ë§¤ìˆ˜ ì „ëµ (Buying Strategy)")
        strategy_group.setStyleSheet("QGroupBox { background-color: #ffffff; border: 1px solid #ccc; border-radius: 8px; margin-top: 10px; padding: 10px; font-weight: bold; }")
        strat_vbox = QVBoxLayout()
        strat_vbox.setSpacing(8)

        # 1. Qty Mode (Red Border)
        qty_layout = QHBoxLayout()
        lbl_qty = QLabel("ğŸ”´ 1ì£¼")
        lbl_qty.setFixedWidth(50)
        self.input_qty_val = QLineEdit("1")
        self.input_qty_val.setReadOnly(True) # [ìˆ˜ì •] 1ì£¼ ê³ ì • ì‚¬ì–‘ ë°˜ì˜ (ìˆ˜ì • ë¶ˆê°€)
        self.input_qty_val.setStyleSheet("background-color: #f0f0f0; border: 2px solid #dc3545; border-radius: 5px; padding: 4px; font-weight: bold; color: #555;")
        qty_layout.addWidget(lbl_qty)
        qty_layout.addWidget(self.input_qty_val)
        qty_layout.addWidget(QLabel("ì£¼"))
        strat_vbox.addLayout(qty_layout)

        # 2. Amount Mode (Green Border)
        amt_layout = QHBoxLayout()
        lbl_amt = QLabel("ğŸŸ¢ ê¸ˆì•¡")
        lbl_amt.setFixedWidth(50)
        self.input_amt_val = QLineEdit("100,000")
        self.input_amt_val.setStyleSheet("border: 2px solid #28a745; border-radius: 5px; padding: 4px; font-weight: bold;")
        self.input_amt_val.textEdited.connect(lambda: self.format_comma(self.input_amt_val))
        amt_layout.addWidget(lbl_amt)
        amt_layout.addWidget(self.input_amt_val)
        amt_layout.addWidget(QLabel("ì›"))
        strat_vbox.addLayout(amt_layout)

        # 3. Percent Mode (Blue Border)
        pct_layout = QHBoxLayout()
        lbl_pct = QLabel("ğŸ”µ ë¹„ìœ¨")
        lbl_pct.setFixedWidth(50)
        self.input_pct_val = QLineEdit("10")
        self.input_pct_val.setStyleSheet("border: 2px solid #007bff; border-radius: 5px; padding: 4px; font-weight: bold;")
        pct_layout.addWidget(lbl_pct)
        pct_layout.addWidget(self.input_pct_val)
        pct_layout.addWidget(QLabel("%"))
        strat_vbox.addLayout(pct_layout)

        strategy_group.setLayout(strat_vbox)
        settings_layout.addWidget(strategy_group)

        # Save & Profile Slots Layout
        save_profile_layout = QHBoxLayout()
        
        self.btn_save = QPushButton("ğŸ’¾")
        self.btn_save.setToolTip("ì„¤ì • ì €ì¥")
        self.btn_save.setFixedSize(45, 45) # [ìˆ˜ì •] í¬ê¸° í™•ëŒ€
        self.btn_save.setStyleSheet("background-color: #6c757d; border-radius: 4px; color: white; border: 1px solid #5a6268; font-size: 28px;")
        self.btn_save.clicked.connect(self.on_save_button_clicked)
        save_profile_layout.addWidget(self.btn_save) # Ratio ì œê±°

        save_profile_layout.addSpacing(5)

        # [ìˆ˜ì •] ì‹œí€€ìŠ¤ ìë™ ë²„íŠ¼ (ì²´í¬ë°•ìŠ¤ ëŒ€ì²´)
        # ì•„ì´ì½˜ë§Œ ìˆëŠ” ì²´í¬ ê°€ëŠ¥í•œ ë²„íŠ¼ìœ¼ë¡œ ë³€ê²½. ì¼œì§€ë©´ â–¶ ì ë©¸
        self.btn_seq_auto = QPushButton("â–¶")
        self.btn_seq_auto.setCheckable(True)
        self.btn_seq_auto.setFixedSize(45, 45) # [ìˆ˜ì •] í¬ê¸° í™•ëŒ€
        self.btn_seq_auto.setToolTip("ì‹œí€€ìŠ¤ ìë™ ëª¨ë“œ (í´ë¦­í•˜ì—¬ ON/OFF)\nON ì‹œ: â–¶ê°€ ì ë©¸í•˜ë©° ì¢…ë£Œ ì‹œê°„ ë„ë‹¬ ì‹œ ë‹¤ìŒ í”„ë¡œí•„ë¡œ ì „í™˜\nOFF ì‹œ: ì •ì§€ ìƒíƒœ, ì•ŒëŒë§Œ ìš¸ë¦¼")
        self.btn_seq_auto.setStyleSheet("""
            QPushButton { background-color: #ffffff; border: 1px solid #999; border-radius: 4px; color: #ccc; font-size: 28px; font-weight: bold; }
            QPushButton:checked { background-color: #e0e0e0; border: 1px solid #666; color: #28a745; }
        """)
        self.btn_seq_auto.clicked.connect(self.on_seq_auto_toggled)
        save_profile_layout.addWidget(self.btn_seq_auto)
        
        # ì‹œí€€ìŠ¤ ë²„íŠ¼ìš© íƒ€ì´ë¨¸ (1ì´ˆ ê°„ê²© ì ë©¸)
        self.seq_blink_timer = QTimer(self)
        self.seq_blink_timer.setInterval(1000)
        self.seq_blink_timer.timeout.connect(self.blink_seq_button)
        self.is_seq_blink_on = False

        save_profile_layout.addSpacing(10) # ê°„ê²© ì¡°ì •
        
        self.profile_buttons = []
        for i in range(1, 4):
            btn = QPushButton(str(i))
            btn.setFixedSize(35, 35) # í¬ê¸° ìœ ì§€
            # [ìˆ˜ì •] í…ìŠ¤íŠ¸ê°€ ì•ˆ ë³´ì¸ë‹¤ë©´: í°íŠ¸ ê°•ì œ ì„¤ì • ë° í…ìŠ¤íŠ¸ ì •ë ¬, ìƒ‰ìƒ ëŒ€ë¹„ ê°•í™”
            btn.setStyleSheet("background-color: #ffffff; border: 1px solid #999; border-radius: 4px; font-weight: 900; color: #000000; padding: 0px; font-size: 16px; font-family: 'Arial';")
            btn.clicked.connect(lambda checked, idx=i: self.on_profile_clicked(idx))
            save_profile_layout.addWidget(btn)
            self.profile_buttons.append(btn)
            
        settings_layout.addLayout(save_profile_layout)
        
        settings_layout.addStretch()
        settings_group.setLayout(settings_layout)
        settings_group.setContentsMargins(5, 5, 5, 5) # ì—¬ë°± ì¶•ì†Œ
        left_layout.addWidget(settings_group)

        # 2. Real-time List
        rt_group = QGroupBox("ğŸ“‹ ì‹¤ì‹œê°„ ì¡°ê±´ì‹")
        rt_layout = QVBoxLayout()
        rt_layout.setContentsMargins(5, 5, 5, 5) # ì—¬ë°± ìµœì†Œí™”
        rt_layout.setSpacing(2)
        self.rt_list = QTextEdit()
        self.rt_list.setReadOnly(True)
        self.rt_list.setStyleSheet("background-color: white; color: black; border: 1px solid #ddd;")
        rt_layout.addWidget(self.rt_list)
        
        rt_group.setLayout(rt_layout)
        left_layout.addWidget(rt_group)

        # === Right Panel: Controls & Logs ===

        right_panel = QFrame()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)

        # Header Layout Removed (Moved to Global)

        # Control Buttons
        btn_layout = QHBoxLayout()
        
        self.btn_start = QPushButton("â–¶ START")
        self.btn_start.setStyleSheet("background-color: #28a745; height: 35px; font-size: 14px;")
        self.btn_start.clicked.connect(self.on_start_clicked)
        
        self.btn_stop = QPushButton("â¹ STOP")
        self.btn_stop.setStyleSheet("background-color: #dc3545; height: 35px; font-size: 14px;")
        def on_stop():
            self.animate_button_click(self.btn_stop)
            self.worker.schedule_command('stop')
        self.btn_stop.clicked.connect(on_stop)
        
        self.btn_report = QPushButton("ğŸ“Š REPORT")
        self.btn_report.setStyleSheet("background-color: #17a2b8; height: 35px; font-size: 14px;")
        def on_report():
            self.animate_button_click(self.btn_report)
            self.worker.schedule_command('report')
        self.btn_report.clicked.connect(on_report)

        btn_layout.addWidget(self.btn_start)
        btn_layout.addWidget(self.btn_stop)
        btn_layout.addWidget(self.btn_report)
        right_layout.addLayout(btn_layout)

        # System Log
        log_group = QGroupBox("ğŸ“„ System Logs")
        log_layout = QVBoxLayout()
        self.log_text = QTextEdit()
        self.log_text.setReadOnly(True)
        log_layout.addWidget(self.log_text)
        log_group.setLayout(log_layout)
        right_layout.addWidget(log_group)

        # Command Input
        input_layout = QHBoxLayout()
        input_label = QLabel("ëª…ë ¹ì–´ ì…ë ¥:")
        self.cmd_input = QLineEdit()
        self.cmd_input.returnPressed.connect(self.send_command)
        
        btn_send = QPushButton("ì „ì†¡")
        btn_send.setStyleSheet("background-color: #fff; color: #333; border: 1px solid #ccc;")
        btn_send.clicked.connect(self.send_command)

        input_layout.addWidget(input_label)
        input_layout.addWidget(self.cmd_input)
        input_layout.addWidget(btn_send)
        right_layout.addLayout(input_layout)

        # Add panels to body layout
        body_layout.addWidget(left_panel)
        body_layout.addWidget(right_panel)
        body_layout.setStretch(1, 1) # Right panel takes remaining space

    def animate_button_click(self, btn):
        """ë²„íŠ¼ í´ë¦­ ì‹œ ìƒ‰ìƒ ë°˜ì „ ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼"""
        original_style = btn.styleSheet()
        # [íš¨ê³¼] ì ì‹œ ë°ê²Œ/ì–´ë‘¡ê²Œ ë³€ê²½
        btn.setStyleSheet("background-color: #555; color: white; border: 2px solid white;")
        QTimer.singleShot(150, lambda: btn.setStyleSheet(original_style))

    def on_start_clicked(self, force=False):
        # [ì‹ ê·œ] ë²„íŠ¼ ì• ë‹ˆë©”ì´ì…˜ ë° ì¤‘ë³µ ë°©ì§€
        self.animate_button_click(self.btn_start)
        
        # [ìˆ˜ì •] forceê°€ Trueì´ë©´ ë²„íŠ¼ ìƒíƒœì™€ ê´€ê³„ì—†ì´ ì§„í–‰ (ì‹œí€€ìŠ¤ ì „í™˜ìš©)
        if not force and not self.btn_start.isEnabled(): return
        self.btn_start.setEnabled(False) # ì¦‰ì‹œ ë¹„í™œì„±í™”í•˜ì—¬ ì¤‘ë³µ í´ë¦­ ë°©ì§€

        # 1. UIì˜ í˜„ì¬ ëª¨ë“  ì„¤ì •ì„ ê¸°ë³¸(root) ì„¤ì •ì— ë™ê¸°í™”
        try:
            # [ìˆ˜ì •] restart_if_running=Falseë¡œ ì„¤ì •í•˜ì—¬ on_start_clicked ë‚´ë¶€ì—ì„œì˜ ë¬´í•œ ë£¨í”„/ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
            self.save_settings(restart_if_running=False) 
            
            # [ìˆ˜ì •] ë¡œê·¸ ìˆœì„œ ì¡°ì • (ì—”ì§„ ì‹œì‘ ì´í›„ì— ë‚˜ì˜¤ë„ë¡ ì •ë³´ë¥¼ ì „ë‹¬)
            target_profile = f"{self.current_profile_idx}ë²ˆ í”„ë¡œí•„" if self.current_profile_idx else "ê¸°ë³¸ ì„¤ì •"
            
        except Exception as e:
            self.append_log(f"âš ï¸ ì„¤ì • ë™ê¸°í™” ì‹¤íŒ¨: {e}")
            target_profile = None
            self.btn_start.setEnabled(True) # ì‹¤íŒ¨ ì‹œ ë‹¤ì‹œ í™œì„±í™”
            
        # 2. ì‹œì‘ ëª…ë ¹ ì „ë‹¬ (target_profileì„ ì¸ìë¡œ ì „ë‹¬í•˜ì—¬ ì—”ì§„ ê°€ë™ í›„ ì¶œë ¥ë˜ê²Œ í•¨)
        QTimer.singleShot(500, lambda: self.worker.schedule_command('start', target_profile))

    def setup_worker(self):
        self.worker = AsyncWorker(self)
        self.worker.signals.log_signal.connect(self.append_log)
        self.worker.signals.status_signal.connect(self.update_status_ui)
        self.worker.signals.clr_signal.connect(self.log_text.clear)
        self.worker.signals.request_log_signal.connect(self.save_logs_to_file)
        self.worker.start()

    def update_status_ui(self, status):
        if status == "RUNNING":
            self.lbl_status.setText("â— RUNNING")
            self.lbl_status.setStyleSheet("color: #28a745; margin-left: 10px;")
            self.btn_start.setEnabled(False)
            self.btn_start.setStyleSheet("background-color: #6c757d; height: 35px; font-size: 14px;")
        elif status == "WAITING":
            self.lbl_status.setText("â— WAITING")
            self.lbl_status.setStyleSheet("color: #ffc107; margin-left: 10px;") # ë…¸ë€ìƒ‰
            # [ìˆ˜ì •] WAITING ìƒíƒœì—ì„œë„ ì‚¬ìš©ìê°€ ì›í•˜ë©´ ë‹¤ì‹œ STARTë¥¼ ëˆ„ë¥¼ ìˆ˜ ìˆë„ë¡ í™œì„±í™” (DEAD ë²„íŠ¼ ë°©ì§€)
            self.btn_start.setEnabled(True) 
            self.btn_start.setStyleSheet("background-color: #28a745; height: 35px; font-size: 14px;")
        else:
            self.lbl_status.setText("â— READY")
            self.lbl_status.setStyleSheet("color: #6c757d; margin-left: 10px;")
            self.btn_start.setEnabled(True)
            self.btn_start.setStyleSheet("background-color: #28a745; height: 35px; font-size: 14px;")

    def append_log(self, text):
        # [ì¶”ê°€] ë¶ˆí•„ìš”í•˜ê±°ë‚˜ ê¸°ìˆ ì ì¸ ë¡œê·¸ í•„í„°ë§
        filter_keywords = [
            "Disconnected from WebSocket server",
            "Message sent:",
            "ì‹¤ì‹œê°„ ì‹œì„¸ ì„œë²„ ì‘ë‹µ ìˆ˜ì‹ (data):",
            "ì„œë²„ì™€ ì—°ê²°ì„ ì‹œë„ ì¤‘ì…ë‹ˆë‹¤.",
            "ì‹¤ì‹œê°„ ì‹œì„¸ ì„œë²„ë¡œ ë¡œê·¸ì¸ íŒ¨í‚·ì„ ì „ì†¡í•©ë‹ˆë‹¤.",
            "ë¡œê·¸ì¸ ì„±ê³µí•˜ì˜€ìŠµë‹ˆë‹¤.",
            "Connection error:"
        ]
        
        if any(keyword in text for keyword in filter_keywords):
            return

        timestamp = datetime.datetime.now().strftime("%H:%M:%S")
        
        # [ìˆ˜ì •] ë“¤ì—¬ì“°ê¸° ë° ì •ë ¬ ì²˜ë¦¬
        # ì‹œê°„ ì˜ì—­([HH:MM:SS])ì„ ê³ ì • ë„ˆë¹„ë¡œ ë‘ê³ , ë©”ì‹œì§€ëŠ” ê·¸ ë„ˆë¹„ë§Œí¼ ì™¼ìª½ ë§ˆì§„ì„ ì£¼ì–´ ì •ë ¬
        text_html = text.replace('\n', '<br>')
        
        # TABLE í˜•íƒœì˜ ë ˆì´ì•„ì›ƒì„ ì‚¬ìš©í•˜ì—¬ ì‹œê°„ê³¼ ë©”ì‹œì§€ë¥¼ ë¶„ë¦¬
        full_html = f"""
        <table border="0" cellpadding="0" cellspacing="0" style="margin-bottom: 2px;">
            <tr>
                <td valign="top" style="width: 70px; color: #ccc; font-family: 'Courier New'; font-size: 11px; white-space: nowrap;">
                    [{timestamp}]
                </td>
                <td valign="top" style="padding-left: 5px; color: #00ff00; font-family: 'Consolas', 'Monospace';">
                    {text_html if '<font color' in text_html or '<span style' in text_html else f"<span>{text_html}</span>"}
                </td>
            </tr>
        </table>
        """
        self.log_text.append(full_html)
        
        # ì¡°ê±´ì‹ ëª©ë¡ì´ë©´ ì™¼ìª½ íŒ¨ë„ì—ëŠ” **ì„ íƒëœ ì¡°ê±´ì‹ë§Œ** í•„í„°ë§í•˜ì—¬ í‘œì‹œ
        if "ğŸ“‹ [ì¡°ê±´ì‹ ëª©ë¡]" in text:
            filtered_msg = ""
            lines = text.split('\n')
            
            # í˜„ì¬ UIì—ì„œ ì²´í¬ëœ ë²ˆí˜¸ë“¤ ê°€ì ¸ì˜¤ê¸°
            checked_indices = [str(i) for i, btn in enumerate(self.cond_buttons) if btn.isChecked()]
            
            found_any = False
            for line in lines:
                if line.startswith('â€¢'):
                    # í¬ë§·: "â€¢ 0: ì¡°ê±´ì‹ì´ë¦„" -> ":" ê¸°ì¤€ìœ¼ë¡œ ë¶„ë¦¬
                    try:
                        parts = line.split(':')
                        idx = parts[0].replace('â€¢', '').strip()
                        
                        if idx in checked_indices:
                            filtered_msg += line + "\n"
                            found_any = True
                    except:
                        pass
            
            if not found_any:
                filtered_msg += "(ì„ íƒëœ ì¡°ê±´ì‹ì´ ëª©ë¡ì— ì—†ìŠµë‹ˆë‹¤)"
                
            self.rt_list.setText(filtered_msg)
            
        # Auto scroll
        sb = self.log_text.verticalScrollBar()
        sb.setValue(sb.maximum())

    def save_logs_to_file(self):
        """í˜„ì¬ ë¡œê·¸ì°½ì˜ ë‚´ìš©ì„ Log_YYYYMMDD_y.txt í˜•ì‹ìœ¼ë¡œ ì €ì¥í•©ë‹ˆë‹¤."""
        try:
            # 1. ì¼ë°˜ í…ìŠ¤íŠ¸ ì¶”ì¶œ (HTML ì œê±°ëœ í“¨ì–´ í…ìŠ¤íŠ¸)
            raw_text = self.log_text.toPlainText()
            
            # 2. ë‚ ì§œ ë° ì¼ë ¬ë²ˆí˜¸ ê²°ì •
            today_str = datetime.datetime.now().strftime("%Y%m%d")
            y = 1
            while True:
                filename = f"Log_{today_str}_{y}.txt"
                filepath = os.path.join(self.script_dir, filename)
                if not os.path.exists(filepath):
                    break
                y += 1
            
            # 3. íŒŒì¼ ì €ì¥
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(raw_text)
            
            msg = f"ğŸ’¾ ë¡œê·¸ íŒŒì¼ ì €ì¥ ì™„ë£Œ: {filename}"
            self.append_log(msg)
            
            # í…”ë ˆê·¸ë¨ìœ¼ë¡œë„ ì•Œë¦¼ (tel_send ëª¨ë“ˆ ì§ì ‘ ì‚¬ìš©)
            from tel_send import tel_send
            tel_send(msg)
            
        except Exception as e:
            err_msg = f"âŒ ë¡œê·¸ ì €ì¥ ì‹¤íŒ¨: {e}"
            self.append_log(err_msg)
            from tel_send import tel_send
            tel_send(err_msg)


    def send_command(self):
        cmd = self.cmd_input.text().strip()
        if cmd:
            if cmd.upper() == 'PRINT':
                self.export_log()
            elif cmd.lower() == 'clr':
                self.log_text.clear()
                self.append_log("ğŸ§¹ ë¡œê·¸ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.")
            else:
                self.worker.schedule_command('custom', cmd)
            self.cmd_input.clear()

    def export_log(self):
        try:
            now_str = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"KIPOSTOCK_LOG_{now_str}.txt"
            
            # í˜„ì¬ ì‹¤í–‰ íŒŒì¼ ìœ„ì¹˜ì— ì €ì¥
            log_path = os.path.join(self.script_dir, filename)
            
            content = self.log_text.toPlainText()
            
            with open(log_path, 'w', encoding='utf-8') as f:
                f.write(content)
                
            # [ìˆ˜ì •] ë¡œê·¸ ì €ì¥ ë©”ì‹œì§€ ìŠ¤íƒ€ì¼ë§: ë“¤ì—¬ì“°ê¸°, ì´íƒ¤ë¦­, ë°‘ì¤„ ì ìš©
            # HTML íƒœê·¸ëŠ” append_log(html=True) ì²˜ë¦¬ê°€ í•„ìš”í•  ìˆ˜ ìˆìœ¼ë‚˜ 
            # í˜„ì¬ append_logê°€ ëª¨ë“  ì…ë ¥ì„ html_textë¡œ ê°ì‹¸ë¯€ë¡œ ìˆ˜ë™ìœ¼ë¡œ í¬ë§·íŒ…
            save_msg = f"ğŸ’¾ ë¡œê·¸ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤:<br>" + "&nbsp;"*11 + f"<u><i>{filename}</i></u>"
            self.append_log(save_msg)
            
            # ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼ (ì„ íƒ ì‚¬í•­)
            # QMessageBox.information(self, "ë¡œê·¸ ì €ì¥", f"ë¡œê·¸ê°€ íŒŒì¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.\n{filename}")
            
        except Exception as e:
            self.append_log(f"âŒ ë¡œê·¸ ì €ì¥ ì‹¤íŒ¨: {e}")

    def on_cond_clicked(self, idx):
        # State: 0 (Off/Gray), 1 (Red/Qty), 2 (Green/Amt), 3 (Blue/Pct)
        self.cond_states[idx] = (self.cond_states[idx] + 1) % 4
        self.update_button_style(idx)
        # [ì‹ ê·œ] ë¦¬ìŠ¤íŠ¸ ì¦‰ì‹œ ê°±ì‹ 
        self.refresh_condition_list_ui()
        
        # [ì‹ ê·œ] ë™ì  ë°˜ì˜ (ì„¤ì • ì €ì¥ í›„ ì—”ì§„ì— ì•Œë¦¼)
        self.save_settings(show_limit_warning=False, restart_if_running=False, quiet=True)
        if self.lbl_status.text() == "â— RUNNING":
            # workerì— refresh_conditions ëª…ë ¹ ì „ë‹¬ (settings.jsonì„ ë‹¤ì‹œ ì½ì–´ì„œ ë°˜ì˜)
            self.worker.schedule_command('refresh_conditions')

    def update_button_style(self, idx):
        # [ì‹ ê·œ] ë²ˆí˜¸ê°€ ì•ˆ ë³´ì´ëŠ” ë¬¸ì œ í•´ê²°ì„ ìœ„í•´ í…ìŠ¤íŠ¸ ê°•ì œ ì„¤ì •
        self.cond_buttons[idx].setText(str(idx))
        
        # State colors: Off(Gray), ğŸ”´(Red), ğŸŸ¢(Green), ğŸ”µ(Blue)
        colors = {0: "#e0e0e0", 1: "#dc3545", 2: "#28a745", 3: "#007bff"}
        text_colors = {0: "#333", 1: "white", 2: "white", 3: "white"}
        
        c = colors.get(self.cond_states[idx], "#e0e0e0")
        tc = text_colors.get(self.cond_states[idx], "#333")
        
        # [ìˆ˜ì •] ë²ˆí˜¸ê°€ ì¤‘ì•™ì— ì˜ ë³´ì´ë„ë¡ í°íŠ¸ í¬ê¸°ì™€ íŒ¨ë”© ì¡°ì •
        self.cond_buttons[idx].setStyleSheet(f"""
            QPushButton {{ 
                background-color: {c}; 
                color: {tc}; 
                font-weight: bold; 
                border-radius: 4px;
                border: 1px solid #999;
                font-size: 11px;
                padding: 0px;
            }}
        """)

    def refresh_condition_list_ui(self):
        """ì‹¤ì‹œê°„ ì¡°ê±´ì‹ ë¦¬ìŠ¤íŠ¸ íŒ¨ë„ì„ í˜„ì¬ ì„ íƒëœ ìƒíƒœì— ë§ì¶° ê°±ì‹ """
        try:
            # 1. ê³ ìœ í•œ ê²€ìƒ‰ì‹ ì´ë¦„ ì‚¬ì „ ì ‘ê·¼ (Worker -> ChatCommand -> RealTimeSearch)
            condition_map = {}
            if self.worker and hasattr(self.worker, 'chat_command') and hasattr(self.worker.chat_command, 'rt_search'):
                 condition_map = self.worker.chat_command.rt_search.condition_map

            # html = "<b>[ í˜„ì¬ ì„ íƒëœ ì¡°ê±´ì‹ ]</b><br><br>" # ì œê±° ìš”ì²­
            html = ""
            active_count = 0
            
            # 2. ë²„íŠ¼ ìƒíƒœ ìˆœíšŒ
            mode_names = {1: "1ì£¼", 2: "ê¸ˆì•¡", 3: "ë¹„ìœ¨"}
            mode_colors = {1: "#dc3545", 2: "#28a745", 3: "#007bff"}
            
            for i, state in enumerate(self.cond_states):
                if state > 0:
                    active_count += 1
                    name = condition_map.get(str(i), f"ì¡°ê±´ì‹ {i}")
                    m_name = mode_names[state]
                    m_color = mode_colors[state]
                    
                    # HTML í¬ë§·: ìƒ‰ìƒ ì ìš©ëœ ì´ë¦„ê³¼ ëª¨ë“œ í‘œì‹œ
                    html += f"&nbsp;â€¢ <span style='color:{m_color};'><b>{i}: {name}</b> ({m_name})</span><br>"
            
            if active_count == 0:
                html = "<br><center>(ì„ íƒëœ ì¡°ê±´ì‹ì´ ì—†ìŠµë‹ˆë‹¤)</center>"
                
            self.rt_list.setHtml(html)
            
        except Exception as e:
            print(f"âš ï¸ ë¦¬ìŠ¤íŠ¸ ê°±ì‹  ì‹¤íŒ¨: {e}")

    def format_comma(self, line_edit):
        text = line_edit.text().replace(',', '')
        if not text: return
        try:
            val = int(text)
            line_edit.setText(f"{val:,}")
        except:
            pass

    def toggle_blink(self):
        if not self.alarm_playing:
            self.blink_timer.stop()
            return
            
        self.is_blink_on = not self.is_blink_on
        if self.is_blink_on:
            self.btn_alarm_stop.setStyleSheet("""
                QPushButton { background-color: #ffc107; color: #000; border: 1px solid #e0a800; border-radius: 4px; font-size: 16px; }
            """)
        else:
            self.btn_alarm_stop.setStyleSheet("""
                QPushButton { background-color: #dc3545; color: #fff; border: 1px solid #c82333; border-radius: 4px; font-size: 16px; }
            """)

    def check_alarm(self):
        # ì´ë¯¸ ìš¸ë¦¬ê³  ìˆìœ¼ë©´ íŒ¨ìŠ¤
        if self.alarm_playing:
            return

        # í”„ë¡œê·¸ë¨ ì‹œì‘ í›„ 5ì´ˆê°„ì€ ì•ŒëŒ ì²´í¬ ìŠ¤í‚µ (ì´ˆê¸°í™” ì•ˆì •í™” ëŒ€ê¸°)
        if (datetime.datetime.now() - self.app_start_time).total_seconds() < 5:
            return

        # [ì‹ ê·œ] ìƒë‹¨ ì‹œê³„ ì—…ë°ì´íŠ¸
        now = datetime.datetime.now()
        self.lbl_clock.setText(now.strftime("%H:%M:%S"))

        current_time_str = now.strftime("%H:%M")
        
        # -------------------------------------------------------------
        # âœ… 1. ì‹œì‘ ì‹œê°„ ì²´í¬ (Start Time Check)
        # -------------------------------------------------------------
        # ì„¤ì •ëœ ì‹œì‘ ì‹œê°„ê³¼ ì¼ì¹˜í•˜ê³ , í˜„ì¬ ìƒíƒœê°€ READYë¼ë©´ ìë™ ì‹œì‘
        try:
            start_time_str = self.input_start_time.text().strip()
            # ì‹œê°„ í¬ë§· ì •ê·œí™”
            target_start = datetime.datetime.strptime(start_time_str, "%H:%M").strftime("%H:%M")
        except:
            target_start = start_time_str

        if current_time_str == target_start:
            # [ìˆ˜ì •] ë¶„ ë‹¨ìœ„ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ (ì´ë¯¸ ì‹¤í–‰í•œ ì‹œê°„ëŒ€ë©´ íŒ¨ìŠ¤)
            if self.last_auto_start_time != current_time_str:
                # ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ (ë¶„ ë‹¨ìœ„ ì²´í¬ì´ë¯€ë¡œ 1ë¶„ ë™ì•ˆ ê³„ì† ì‹¤í–‰ë  ìˆ˜ ìˆìŒ -> last_check_time ë“±ìœ¼ë¡œ ë°©ì§€ í•„ìš”í•˜ì§€ë§Œ 
                # ì—¬ê¸°ì„œëŠ” ìƒíƒœê°€ READYì¼ ë•Œë§Œ ë™ì‘í•˜ë¯€ë¡œ ìì—°ìŠ¤ëŸ½ê²Œ ë°©ì–´ë¨)
                if self.lbl_status.text() == "â— READY":
                    self.last_auto_start_time = current_time_str # ì‹¤í–‰ ì‹œê°„ ê¸°ë¡
                    self.append_log(f"â° ì‹œì‘ ì‹œê°„({target_start}) ë„ë‹¬: ìë™ ì‹œì‘í•©ë‹ˆë‹¤.")
                    # ì§§ì€ ë¹„í”„ìŒ
                    winsound.MessageBeep(winsound.MB_ICONASTERISK)
                    # ì‹œì‘ ëª…ë ¹ ì‹¤í–‰
                    self.on_start_clicked() # ì €ì¥ í›„ ì‹œì‘ ë¡œì§ ì¬ì‚¬ìš©

        # -------------------------------------------------------------
        # âœ… 2. ì¢…ë£Œ ì‹œê°„ ì²´í¬ (End Time Check)
        # -------------------------------------------------------------
        end_time_str = self.input_end_time.text().strip()
        try:
            target_end = datetime.datetime.strptime(end_time_str, "%H:%M").strftime("%H:%M")
        except:
            target_end = end_time_str

        # ì‹œê°„ì´ ì¼ì¹˜í•˜ê³ , ë°©ê¸ˆ ëˆ ì‹œê°„(last_alarm_time)ì´ ì•„ë‹ˆë¼ë©´
        # [ìˆ˜ì •] ë™ì¼í•œ ë¶„ì— ì‹œì‘ê³¼ ì¢…ë£Œê°€ ë™ì‹œì— ì¼ì–´ë‚˜ëŠ” ë ˆì´ìŠ¤ ì»¨ë””ì…˜ ë°©ì§€
        if current_time_str == target_end:
            if self.last_alarm_time != current_time_str and self.last_auto_start_time != current_time_str:
                self.handle_end_time_event(current_time_str)

 

    # def play_subprocess_sound(self):  <-- ë©”ì„œë“œ ì œê±°
    #     pass

    def stop_alarm(self):
        if self.alarm_playing:
            # ì†Œë¦¬ ì¤‘ë‹¨
            try:
                winsound.PlaySound(None, winsound.SND_PURGE)
            except: pass
            
            self.alarm_playing = False
            self.last_alarm_time = datetime.datetime.now().strftime("%H:%M") # í˜„ì¬ ë¶„ì—ëŠ” ë‹¤ì‹œ ì•ˆ ìš¸ë¦¼
            
            self.blink_timer.stop() # ê¹œë¹¡ì„ ì¤‘ë‹¨
            self.btn_alarm_stop.setEnabled(False)
            self.btn_alarm_stop.setText("ğŸ”•")
            self.btn_alarm_stop.setStyleSheet("""
                QPushButton {
                    background-color: #f8f9fa;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    font-size: 16px;
                    color: #aaa;
                }
            """)
            self.append_log("ğŸ”• ì•ŒëŒì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤.")

    def update_strategy_ui(self, from_user_click=False):
        # Legacy stub for backward compatibility if called elsewhere
        pass

    def format_input_value(self, text):
        # Legacy stub
        pass

    def load_settings_to_ui(self, profile_idx=None, keep_seq_auto=False):
        try:
            with open(self.settings_file, 'r', encoding='utf-8') as f:
                settings = json.load(f)
            
            target = settings
            if profile_idx is not None:
                profiles = settings.get('profiles', {})
                target = profiles.get(str(profile_idx))
                if not target:
                    self.append_log(f"âš ï¸ í”„ë¡œí•„ {profile_idx}ë²ˆ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
                    return
                self.append_log(f"ğŸ“‚ í”„ë¡œí•„ {profile_idx}ë²ˆ ì„¤ì •ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.")

            self.input_profit.setText(str(target.get('take_profit_rate', '12.0')))
            self.input_loss.setText(str(target.get('stop_loss_rate', '-1.2')))
            self.input_max.setText(str(target.get('max_stocks', '20')))
            
            # Condition Button Set
            seq_data = target.get('search_seq', [])
            if isinstance(seq_data, str):
                try:
                    parsed = ast.literal_eval(seq_data)
                    seq_data = parsed if isinstance(parsed, list) else [seq_data]
                except: seq_data = [seq_data]
            elif isinstance(seq_data, int): seq_data = [str(seq_data)]
                
            seq_set = set(map(str, seq_data))
            for i, btn in enumerate(self.cond_buttons):
                btn.setChecked(str(i) in seq_set)
            
            self.input_start_time.setText(target.get('start_time', '09:00'))
            self.input_end_time.setText(target.get('end_time', '15:20'))
            self.input_qty_val.setText(str(target.get('qty_val', '1')))
            
            amt_val = target.get('amt_val', '100,000')
            try: amt_val = f"{int(str(amt_val).replace(',', '')):,}"
            except: pass
            self.input_amt_val.setText(amt_val)
            self.input_pct_val.setText(str(target.get('pct_val', '10')))
            
            # [ìˆ˜ì •] ì‹œí€€ìŠ¤ ë²„íŠ¼ ë¡œë“œ ë° UI ë°˜ì˜ (ì „í™˜ ì‹œì—ëŠ” í˜„ì¬ ìƒíƒœ ìœ ì§€)
            if not keep_seq_auto:
                is_seq = target.get('sequence_auto', False)
                self.btn_seq_auto.setChecked(is_seq)
                self.on_seq_auto_toggled() # ìƒíƒœì— ë”°ë¥¸ ìŠ¤íƒ€ì¼ ì ìš©
            
            # Condition 4-State logic
            strat_map = target.get('condition_strategies', {})
            active_seqs = set(map(str, seq_data)) if isinstance(seq_data, (list, set)) else set()

            for i in range(20): # [ìˆ˜ì •] 10ê°œ -> 20ê°œë¡œ í™•ì¥
                mode = strat_map.get(str(i))
                if mode == 'qty': self.cond_states[i] = 1
                elif mode == 'amount': self.cond_states[i] = 2
                elif mode == 'percent': self.cond_states[i] = 3
                else:
                    self.cond_states[i] = 1 if str(i) in active_seqs else 0
                self.update_button_style(i)
            
            # [ì‹ ê·œ] í™œì„±í™”ëœ í”„ë¡œí•„ ë²„íŠ¼ ê°•ì¡° ì²˜ë¦¬
            self.current_profile_idx = profile_idx
            self.update_profile_buttons_ui()

            # [ì‹ ê·œ] ë¡œë“œ ì§í›„ ë¦¬ìŠ¤íŠ¸ ë¦¬í”„ë ˆì‹œ ë° ìš´ì˜ ì‹œê°„ ë™ê¸°í™”
            QTimer.singleShot(500, self.refresh_condition_list_ui)
            
            # [ì‹ ê·œ] ë¡œë“œëœ ì„¤ì •ì— ë§ì¶° MarketHour ì¦‰ì‹œ ë™ê¸°í™” (WAITING ë²„ê·¸ í•´ê²°)
            try:
                sh, sm = map(int, target.get('start_time', '09:00').split(':'))
                eh, em = map(int, target.get('end_time', '15:20').split(':'))
                MarketHour.set_market_hours(sh, sm, eh, em)
            except: pass
            
        except Exception as e:
            self.append_log(f"ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨: {e}")

    def save_settings(self, profile_idx=None, show_limit_warning=True, restart_if_running=True, quiet=False):
        try:
            # UI ê°’ ì½ê¸°
            tpr = self.input_profit.text()
            slr = self.input_loss.text()
            max_s = self.input_max.text()
            st = self.input_start_time.text()
            et = self.input_end_time.text()
            
            # [ìˆ˜ì •] ìš´ì˜ ì‹œê°„ ì œí•œ (09:00 ~ 15:30)
            def clamp_time(t_str, default_val):
                try:
                    h, m = map(int, t_str.strip().split(':'))
                    t_val = h * 100 + m
                    if t_val < 900: return "09:00"
                    if t_val > 1530: return "15:30"
                    return f"{h:02d}:{m:02d}"
                except: return default_val
            
            st = clamp_time(st, "09:00")
            et = clamp_time(et, "15:30")
            
            # UI ê°•ì œ ê°±ì‹ 
            self.input_start_time.setText(st)
            self.input_end_time.setText(et)
            
            selected_seq = []
            cond_strategies = {}
            mode_map = {1: 'qty', 2: 'amount', 3: 'percent'}
            
            for i, state in enumerate(self.cond_states):
                if state > 0:
                    selected_seq.append(str(i))
                    cond_strategies[str(i)] = mode_map[state]

            # [ì‹ ê·œ] 10ê°œ ì´ˆê³¼ ê²½ê³  (ì¦ê¶Œì‚¬ ì •ì±…)
            if show_limit_warning and len(selected_seq) > 10:
                msg = f"âš ï¸ [ì£¼ì˜] ì„ íƒëœ ì¡°ê±´ì‹ì´ {len(selected_seq)}ê°œì…ë‹ˆë‹¤.\nì¦ê¶Œì‚¬ API ì •ì±…ìƒ ë™ì‹œì— ìµœëŒ€ 10ê°œê¹Œì§€ë§Œ ì‹¤ì‹œê°„ ê°ì‹œê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.\nì´ˆê³¼ëœ í•­ëª©ì€ ì„œë²„ì—ì„œ ë“±ë¡ì„ ê±°ë¶€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
                QMessageBox.warning(self, "ì¡°ê±´ì‹ ê°œìˆ˜ ì´ˆê³¼", msg)
                self.append_log(msg.replace("\n", " "))

            qty_val = self.input_qty_val.text()
            amt_val = self.input_amt_val.text()
            pct_val = self.input_pct_val.text()
            
            # í˜„ì¬ ì„¤ì •ì„ ë”•ì…”ë„ˆë¦¬ë¡œ êµ¬ì„±
            current_data = {
                'take_profit_rate': float(tpr),
                'stop_loss_rate': float(slr),
                'max_stocks': int(max_s),
                'start_time': st,
                'end_time': et,
                'qty_val': qty_val,
                'amt_val': amt_val,
                'pct_val': pct_val,
                'condition_strategies': cond_strategies,
                'search_seq': selected_seq,
                'sequence_auto': self.btn_seq_auto.isChecked() # [ìˆ˜ì •] ì‹œí€€ìŠ¤ ë²„íŠ¼ ìƒíƒœ ì €ì¥
            }

            if profile_idx is not None:
                # íŠ¹ì • í”„ë¡œí•„ì— ì €ì¥
                with open(self.settings_file, 'r', encoding='utf-8') as f:
                    settings = json.load(f)
                
                if 'profiles' not in settings: settings['profiles'] = {}
                settings['profiles'][str(profile_idx)] = current_data
                
                with open(self.settings_file, 'w', encoding='utf-8') as f:
                    json.dump(settings, f, ensure_ascii=False, indent=2)
                
                # [ì‹ ê·œ] ì €ì¥ ì‹œì—ë„ MarketHour ì¦‰ì‹œ ë™ê¸°í™”
                try:
                    sh, sm = map(int, st.split(':'))
                    eh, em = map(int, et.split(':'))
                    MarketHour.set_market_hours(sh, sm, eh, em)
                except: pass

                if not quiet:
                    self.append_log(f"ğŸ’¾ í”„ë¡œí•„ {profile_idx}ë²ˆì— ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.")
                    # [ì‹ ê·œ] ì €ì¥ëœ ìƒì„¸ ì„¤ì •ê°’ ì¶œë ¥
                    summary = f"ğŸ“‹ [ì €ì¥ê°’] ìµì ˆ:{tpr}% | ì†ì ˆ:{slr}% | ì¢…ëª©ìˆ˜:{max_s} | ì‹œê°„:{st}~{et} | ì„ íƒ:{len(selected_seq)}ì¢…ëª©"
                    self.append_log(f"<font color='#28a745'>{summary}</font>")
            else:
                # [ìˆ˜ì •] ë ˆì´ìŠ¤ ì»¨ë””ì…˜ ë°©ì§€ë¥¼ ìœ„í•´ ì¼ê´„ ì—…ë°ì´íŠ¸(update_settings) ì‚¬ìš©
                root_updates = {
                    'qty_val': qty_val,
                    'amt_val': amt_val,
                    'pct_val': pct_val,
                    'condition_strategies': cond_strategies,
                    'search_seq': selected_seq,
                    'take_profit_rate': float(tpr),
                    'stop_loss_rate': float(slr),
                    'max_stocks': int(max_s),
                    'start_time': st,
                    'end_time': et
                }
                self.worker.schedule_command('update_settings', root_updates, quiet)
                
                # ì‹œê°„ ì„¤ì • ì¦‰ì‹œ ë°˜ì˜
                try:
                    sh, sm = map(int, st.split(':'))
                    eh, em = map(int, et.split(':'))
                    MarketHour.set_market_hours(sh, sm, eh, em)
                except: pass
                
                self.worker.schedule_command('condition_list', quiet)
                if hasattr(cached_setting, "_cache"): cached_setting._cache = {}
                
                # [ìˆ˜ì •] ì—”ì§„ ì¬ì‹œì‘ ì—¬ë¶€ ì œì–´ (ì¡°ê±´ì‹ ë‹¨ìˆœ ë³€ê²½ ì‹œì—ëŠ” ì¬ì‹œì‘ ì•ˆ í•¨)
                if restart_if_running and "RUNNING" in self.lbl_status.text():
                    self.worker.schedule_command('start')
                
                if not quiet:
                    self.append_log("ğŸ’¾ ê¸°ë³¸ ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.")
                    summary = f"ğŸ“‹ [ì €ì¥ê°’] ìµì ˆ:{tpr}% | ì†ì ˆ:{slr}% | ì¢…ëª©ìˆ˜:{max_s} | ì‹œê°„:{st}~{et} | ì„ íƒ:{len(selected_seq)}ì¢…ëª©"
                    self.append_log(f"<font color='#28a745'>{summary}</font>")

            self.refresh_condition_list_ui()
            
        except ValueError:
            QMessageBox.warning(self, "ì…ë ¥ ì˜¤ë¥˜", "ìˆ«ì í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.")
        except Exception as e:
             QMessageBox.critical(self, "ì˜¤ë¥˜", f"ì €ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")

    # [ë¯¸ì”½ ë©”ì„œë“œ ë³µêµ¬] í”„ë¡œí•„ ë²„íŠ¼ í´ë¦­ í•¸ë“¤ëŸ¬
    def on_profile_clicked(self, idx):
        # [ì‹ ê·œ] ë¡œë“œ ì „ ì‹œí€€ìŠ¤ ë²„íŠ¼ ìƒíƒœ ë°±ì—…
        is_seq_before_load = self.btn_seq_auto.isChecked()

        if self.is_save_mode:
            # ì €ì¥ ëª¨ë“œì¼ ë•Œ: í´ë¦­í•œ í”„ë¡œí•„ì— ì €ì¥
            self.save_settings(profile_idx=idx)
            self.stop_save_mode()
        else:
            # ì¼ë°˜ ëª¨ë“œì¼ ë•Œ: í”„ë¡œí•„ ë¡œë“œ (í˜„ì¬ ì‹œí€€ìŠ¤ ë²„íŠ¼ ìƒíƒœ ê°•ì œ ìœ ì§€)
            self.load_settings_to_ui(profile_idx=idx, keep_seq_auto=True)
            self.current_profile_idx = idx
            self.update_profile_buttons_ui()
            
            # [ìˆ˜ì •] ì‹œí€€ìŠ¤ ìë™ ëª¨ë“œ ì¡°ê±´ ê°•í™” (ê¸°ì¡´ì— ì´ë¯¸ ì¼œì ¸ ìˆì—ˆì„ ë•Œë§Œ ë¡œë“œ í›„ ìë™ ì‹œì‘)
            # ë¡œë“œëœ ì„¤ì •(target)ì— ì˜í•´ ì¼œì§€ëŠ” ê²½ìš°ì—ëŠ” ë°”ë¡œ ì‹œì‘í•˜ì§€ ì•ŠìŒ (ì‚¬ìš©ì í™•ì¸ ìš©ë„)
            if is_seq_before_load and self.btn_seq_auto.isChecked():
                self.append_log(f"ğŸš€ ì‹œí€€ìŠ¤ ìë™: í”„ë¡œí•„ {idx}ë²ˆ ì„ íƒë¨ - ì—”ì§„ì„ ìë™ ì‹œì‘í•©ë‹ˆë‹¤.")
                QTimer.singleShot(1000, self.on_start_clicked)

    # [ë¯¸ì”½ ë©”ì„œë“œ ë³µêµ¬] ì €ì¥ ëª¨ë“œ ì¢…ë£Œ
    def stop_save_mode(self):
        self.is_save_mode = False
        self.profile_blink_timer.stop()
        self.is_profile_blink_on = False
        
        # ë²„íŠ¼ ìŠ¤íƒ€ì¼ ë³µêµ¬
        self.btn_save.setStyleSheet("background-color: #6c757d; border-radius: 4px; color: white; border: 1px solid #5a6268; font-size: 20px;")
        self.update_profile_buttons_ui()

    # [ë¯¸ì”½ ë©”ì„œë“œ ë³µêµ¬] í”„ë¡œí•„ ë²„íŠ¼ UI ì—…ë°ì´íŠ¸ (ë°ì´í„° ìœ ë¬´ í‘œì‹œ)
    def update_profile_buttons_ui(self):
        try:
            settings = {}
            if os.path.exists(self.settings_file):
                with open(self.settings_file, 'r', encoding='utf-8') as f:
                    settings = json.load(f)
            
            profiles = settings.get('profiles', {})
            
            for i, btn in enumerate(self.profile_buttons):
                idx = i + 1
                has_data = str(idx) in profiles
                is_selected = (self.current_profile_idx == idx)
                
                # ê¸°ë³¸ ìŠ¤íƒ€ì¼
                base_style = "border-radius: 4px; font-weight: 900; padding: 0px; font-size: 16px; font-family: 'Arial';"
                
                if is_selected:
                    # ì„ íƒë¨: íŒŒë€ìƒ‰ í…Œë‘ë¦¬ ë˜ëŠ” ë°°ê²½
                    style = f"background-color: #e3f2fd; border: 2px solid #007bff; color: #007bff; {base_style}"
                elif has_data:
                    # ë°ì´í„° ìˆìŒ: íšŒìƒ‰ ë°°ê²½ (ì‚¬ìš©ì ìš”ì²­)
                    style = f"background-color: #cccccc; border: 1px solid #999; color: #333; {base_style}"
                else:
                    # ë¹„ì–´ìˆìŒ: í°ìƒ‰
                    style = f"background-color: #ffffff; border: 1px solid #ddd; color: #ccc; {base_style}"
                
                btn.setStyleSheet(style)
                    
        except Exception as e:
            self.append_log(f"UI ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")

    def on_save_button_clicked(self):
        """ì„¤ì • ì €ì¥ ë²„íŠ¼ í´ë¦­ ì‹œ: ì €ì¥ ëª¨ë“œ ì§„ì… ë° ì ë©¸ ì‹œì‘"""
        if not self.is_save_mode:
            self.is_save_mode = True
            self.profile_blink_timer.start()
            self.append_log("ğŸ’¡ ì €ì¥í•  ë²ˆí˜¸(1~3)ë¥¼ ì„ íƒí•˜ì„¸ìš”. (ë‹¤ì‹œ ëˆ„ë¥´ë©´ ì·¨ì†Œ)")
            self.btn_save.setStyleSheet("background-color: #ffc107; color: black; border-radius: 4px; font-weight: bold;")
        else:
            self.stop_save_mode()
            self.append_log("âŒ ì €ì¥ ëª¨ë“œê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")

    def on_seq_auto_toggled(self):
        """ì‹œí€€ìŠ¤ ìë™ ë²„íŠ¼ í† ê¸€ ì‹œ ì²˜ë¦¬"""
        is_on = self.btn_seq_auto.isChecked()
        if is_on:
            self.seq_blink_timer.start()
            self.append_log("ğŸ”„ ì‹œí€€ìŠ¤ ìë™ ëª¨ë“œ ON: ì¢…ë£Œ ì‹œê°„ ë„ë‹¬ ì‹œ ë‹¤ìŒ í”„ë¡œí•„ë¡œ ì „í™˜í•©ë‹ˆë‹¤.")
            
            # [ì‹ ê·œ] í˜„ì¬ ì´í›„ì˜ ì‹œí€€ìŠ¤ ì •ë³´ ì¶œë ¥
            try:
                if os.path.exists(self.settings_file):
                    with open(self.settings_file, 'r', encoding='utf-8') as f:
                        settings = json.load(f)
                    
                    profiles = settings.get('profiles', {})
                    # í˜„ì¬ í”„ë¡œí•„ ë²ˆí˜¸ë¥¼ ê¸°ì¤€ìœ¼ë¡œ (ì—†ìœ¼ë©´ 1ë²ˆ)
                    current_idx = self.current_profile_idx if self.current_profile_idx is not None else 1
                    
                    self.append_log("="*50)
                    self.append_log("ğŸ“‹ [ì‹œí€€ìŠ¤ ì‘ë™ ì˜ˆì•½ ëª©ë¡]")
                    
                    found_any = False
                    for i in range(current_idx, 4):
                        p = profiles.get(str(i))
                        if p:
                            st = p.get('start_time', '09:00')
                            et = p.get('end_time', '15:20')
                            seqs = p.get('search_seq', [])
                            cond_count = len(seqs)
                            
                            # ì¡°ê±´ì‹ ê°œìˆ˜ ì •ë³´ í¬í•¨
                            log_msg = f"  - í”„ë¡œí•„ {i}ë²ˆ: {st} ~ {et} (ì¡°ê±´ì‹ {cond_count}ê°œ ê°ì‹œ)"
                            if i == current_idx:
                                log_msg += " [í˜„ì¬]"
                            self.append_log(log_msg)
                            found_any = True
                    
                    if not found_any:
                        self.append_log("  (ì˜ˆì•½ëœ í”„ë¡œí•„ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤)")
                    
                    self.append_log("="*50)
            except Exception as e:
                self.append_log(f"âš ï¸ ì‹œí€€ìŠ¤ ì •ë³´ ë¡œë“œ ì¤‘ ì˜¤ë¥˜: {e}")
        else:
            self.seq_blink_timer.stop()
            self.btn_seq_auto.setStyleSheet("""
                QPushButton { background-color: #ffffff; border: 1px solid #999; border-radius: 4px; color: #ccc; font-size: 14px; font-weight: bold; }
            """)
            self.append_log("â¹ ì‹œí€€ìŠ¤ ìë™ ëª¨ë“œ OFF: ì¢…ë£Œ ì‹œê°„ ë„ë‹¬ ì‹œ ì•ŒëŒë§Œ ìš¸ë¦½ë‹ˆë‹¤.")
            self.is_seq_blink_on = False
        
        # [ì‹ ê·œ] ì‹œí€€ìŠ¤ ì‘ë™ ì¤‘ UI ì ê¸ˆ ì²˜ë¦¬
        self.lock_ui_for_sequence(is_on)

    def lock_ui_for_sequence(self, locked):
        """ì‹œí€€ìŠ¤ ìë™ ëª¨ë“œ í™œì„±í™” ì‹œ ì˜¤ì¡°ì‘ ë°©ì§€ë¥¼ ìœ„í•´ UI ì ê¸ˆ"""
        # ... (ìƒëµ) ...
        # [ìˆ˜ì •] READY ìƒíƒœì¼ ë•ŒëŠ” START ë²„íŠ¼ì„ ì ê·¸ì§€ ì•ŠìŒ (ì‚¬ìš©ìê°€ ì‹œì‘í•  ìˆ˜ ìˆë„ë¡)
        is_ready = "READY" in self.lbl_status.text()
        
        # ì…ë ¥ í•„ë“œ ë° ë²„íŠ¼ ì ê¸ˆ
        self.input_profit.setEnabled(not locked)
        self.input_loss.setEnabled(not locked)
        self.input_max.setEnabled(not locked)
        self.input_start_time.setEnabled(not locked)
        self.input_end_time.setEnabled(not locked)
        self.input_qty_val.setEnabled(not locked)
        self.input_amt_val.setEnabled(not locked)
        self.input_pct_val.setEnabled(not locked)
        
        for btn in self.cond_buttons: btn.setEnabled(not locked)
        for btn in self.profile_buttons: btn.setEnabled(not locked)
        self.btn_save.setEnabled(not locked)
        
        # START ë²„íŠ¼ì€ READY ìƒíƒœë©´ ì ê·¸ì§€ ì•ŠìŒ
        self.btn_start.setEnabled(not locked or is_ready)
        self.btn_stop.setEnabled(not locked) 
        
        if locked:
            self.append_log("ğŸ”’ UI ì ê¸ˆ: ì‹œí€€ìŠ¤ ì‘ë™ ì¤‘ì—ëŠ” ì„¤ì •ì„ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        else:
            self.append_log("ğŸ”“ UI ì ê¸ˆ í•´ì œ: ì„¤ì •ì„ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
            # [ìˆ˜ì •] ì ê¸ˆ í•´ì œ ì‹œ í˜„ì¬ ìƒíƒœ(RUNNING/READY)ì— ë§ì¶° ë²„íŠ¼ í™œì„±í™” ìƒíƒœ ë³µêµ¬
            current_status = self.lbl_status.text().replace("â— ", "").strip()
            self.update_status_ui(current_status)

    def blink_seq_button(self):
        """ì‹œí€€ìŠ¤ ë²„íŠ¼ ì ë©¸ íš¨ê³¼ (1ì´ˆ ë‹¨ìœ„)"""
        # ì²´í¬ëœ ìƒíƒœì—¬ì•¼ë§Œ ì ë©¸
        if not self.btn_seq_auto.isChecked():
            self.seq_blink_timer.stop()
            return

        self.is_seq_blink_on = not self.is_seq_blink_on
        if self.is_seq_blink_on:
            # ì¼œì§: ë…¹ìƒ‰ í…ìŠ¤íŠ¸ & ì•½ê°„ ì§„í•œ ë°°ê²½
            self.btn_seq_auto.setStyleSheet("""
                QPushButton { background-color: #e8f5e9; border: 2px solid #28a745; border-radius: 4px; color: #28a745; font-size: 14px; font-weight: bold; }
            """)
        else:
            # êº¼ì§: ê¸°ë³¸ ì²´í¬ ìƒíƒœ
            self.btn_seq_auto.setStyleSheet("""
                QPushButton { background-color: #e0e0e0; border: 1px solid #666; border-radius: 4px; color: #28a745; font-size: 14px; font-weight: bold; }
            """)

    def handle_end_time_event(self, current_time_str):
        """ì¢…ë£Œ ì‹œê°„ ë„ë‹¬ ì‹œ ì‹œí€€ìŠ¤ ë¡œì§ ì²˜ë¦¬"""
        # 1. ì‹œí€€ìŠ¤ ìë™ ëª¨ë“œì¸ì§€ í™•ì¸
        is_seq_auto = self.btn_seq_auto.isChecked() # [ìˆ˜ì •] ë²„íŠ¼ ìƒíƒœ í™•ì¸
        current_idx = self.current_profile_idx

        if is_seq_auto and current_idx is not None:
            # [ì‹œí€€ìŠ¤ ON] ë‹¤ìŒ í”„ë¡œí•„ë¡œ ì „í™˜ ì‹œë„
            next_idx = current_idx + 1
            if next_idx <= 3: # ìµœëŒ€ 3ë²ˆ í”„ë¡œí•„ê¹Œì§€ë§Œ
                # ë‹¤ìŒ í”„ë¡œí•„ ë°ì´í„° í™•ì¸
                try:
                    if os.path.exists(self.settings_file):
                        with open(self.settings_file, 'r', encoding='utf-8') as f:
                            settings = json.load(f)
                            if 'profiles' in settings and str(next_idx) in settings['profiles']:
                                self.append_log(f"ğŸ”„ ì‹œí€€ìŠ¤ ìë™: í”„ë¡œí•„ {current_idx}ë²ˆ ì¢…ë£Œ -> {next_idx}ë²ˆìœ¼ë¡œ ì „í™˜í•©ë‹ˆë‹¤.")
                                
                                # 1) í˜„ì¬ ì„¤ì • ì €ì¥
                                self.save_settings(profile_idx=current_idx, restart_if_running=False) # ì „í™˜ ì¤‘ ì¤‘ë³µ ì‹œì‘ ë°©ì§€
                                
                                # 2) ë‹¤ìŒ í”„ë¡œí•„ ë¡œë“œ (UIì™€ ë‚´ë¶€ ë³€ìˆ˜ ë™ê¸°í™”, ì‹œí€€ìŠ¤ ì˜¨ ìœ ì§€)
                                self.load_settings_to_ui(profile_idx=next_idx, keep_seq_auto=True)
                                
                                # 3) ì•ŒëŒ ë°œìƒ (ë‹¤ìŒ í”„ë¡œí•„ ì „í™˜ ì•Œë¦¼)
                                self.start_alarm(transition_to=next_idx)
                                
                                # 4) ì„¤ì • ì ìš© ë° ì—”ì§„ ì¬ê°€ë™ (API ì¬ë“±ë¡ ê°•ì œ ìˆ˜í–‰)
                                self.append_log("="*40)
                                self.append_log(f"ğŸ›°ï¸ [ì‹œí€€ìŠ¤] {next_idx}ë²ˆ í”„ë¡œí•„ë¡œ ì „í™˜: API ê²€ìƒ‰ì‹ ì¬ë“±ë¡ì„ ì‹œì‘í•©ë‹ˆë‹¤...")
                                self.append_log("="*40)
                                
                                # [ìˆ˜ì •] ì „í™˜ ì¤‘ ì¤‘ë³µ ì•ŒëŒ/ì´ë²¤íŠ¸ ë°©ì§€ë¥¼ ìœ„í•´ ì¦‰ì‹œ ì‹œê°„ ê¸°ë¡
                                self.last_alarm_time = current_time_str
                                
                                # [ìˆ˜ì •] ì‹œí€€ìŠ¤ ì „í™˜ ë”œë ˆì´ë¥¼ 2.5ì´ˆ -> 5ì´ˆë¡œ ì¦ê°€í•˜ì—¬ R10001 ì¤‘ë³µ ë¡œê·¸ì¸ ë°©ì§€
                                # ì´ì „ í”„ë¡œí•„ì˜ ì„¸ì…˜ì´ ì™„ì „íˆ ì •ë¦¬ë  ì‹œê°„ì„ í™•ë³´í•©ë‹ˆë‹¤.
                                QTimer.singleShot(5000, lambda: self.on_start_clicked(force=True)) 
                                return
                except Exception as e:
                    self.append_log(f"âš ï¸ ì‹œí€€ìŠ¤ ì „í™˜ ì¤‘ ì˜¤ë¥˜: {e}")

            # ë‹¤ìŒ í”„ë¡œí•„ì´ ì—†ê±°ë‚˜ ë°ì´í„°ê°€ ì—†ìœ¼ë©´ (ìµœì¢… ì‹œí€€ìŠ¤ ì¢…ë£Œ)
            self.append_log("ğŸ ì‹œí€€ìŠ¤ ì¢…ë£Œ: ëª¨ë“  í”„ë¡œí•„ ë‹¨ê³„ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")
            
            # ì‹œí€€ìŠ¤ ì¢…ë£Œ ì‹œ ë²„íŠ¼ ë„ê¸° ë° UI ì ê¸ˆ í•´ì œ
            self.btn_seq_auto.setChecked(False)
            self.on_seq_auto_toggled() 
            
            # [ì¶”ê°€] UI ì™„ì „ ì´ˆê¸°í™” ë° ë²„íŠ¼ ìƒíƒœ ë³µêµ¬
            self.lock_ui_for_sequence(False)
            self.update_status_ui("READY")
            self.append_log("ğŸ”“ ì‹œí€€ìŠ¤ ì¢…ë£Œ: ëª¨ë“  UI ì¡°ì‘ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.")
            
            self.start_alarm() # ë§ˆì§€ë§‰ ì¢…ë£Œ ì•ŒëŒ
            self.worker.schedule_command('stop') # ë§¤ë§¤ ì¤‘ë‹¨
            
            # [ìˆ˜ì •] ì¤‘ë‹¨ í›„ ì•½ê°„ì˜ ì—¬ìœ ë¥¼ ë‘ê³  ìµœì¢… ë³´ê³  ì „ì†¡ (workerì— today ì¶”ê°€ë¨)
            QTimer.singleShot(5000, lambda: self.worker.schedule_command('today'))
            return

        # [ì‹œí€€ìŠ¤ OFF]
        self.start_alarm(just_sound=True)

    def start_alarm(self, just_sound=False, transition_to=None):
        # ... (ê¸°ì¡´ start_alarm ë¡œì§) ...
        if self.alarm_playing:
            return
            
        try:
            self.alarm_playing = True
            
            # ë²„íŠ¼ ìƒíƒœ ë³€ê²½
            self.btn_alarm_stop.setEnabled(True)
            self.btn_alarm_stop.setText("ğŸ””") 
            self.blink_timer.start() # ê¹œë¹¡ì„ ì‹œì‘
            
            if transition_to:
                log_msg = f"ğŸ”„ ì‹œí€€ìŠ¤ ì „í™˜: {transition_to}ë²ˆ í”„ë¡œí•„ë¡œ ì´ë™í•©ë‹ˆë‹¤. (ë§¤ë§¤ ê³„ì†)"
            elif just_sound:
                log_msg = f"â° ì¢…ë£Œ ì‹œê°„({self.input_end_time.text()}) ë„ë‹¬! (ë§¤ë§¤ëŠ” ê³„ì†ë©ë‹ˆë‹¤)"
            else:
                log_msg = f"â° ì•ŒëŒ ë°œìƒ: ì¢…ë£Œ ì‹œê°„({self.input_end_time.text()}) ë„ë‹¬!"
                
            self.append_log(log_msg)
            
            sound_path = os.path.join(self.script_dir, "StockAlarm.wav")
            if os.path.exists(sound_path):
                winsound.PlaySound(sound_path, winsound.SND_FILENAME | winsound.SND_ASYNC | winsound.SND_LOOP)
            else:
                self.append_log(f"âš ï¸ ì•ŒëŒ íŒŒì¼ ì—†ìŒ: {sound_path}")
            
        except Exception as e:
            self.append_log(f"âš ï¸ ì•ŒëŒ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {e}")
            self.alarm_playing = False


    def closeEvent(self, event):
        reply = QMessageBox.question(self, 'ì¢…ë£Œ', 'í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?',
                                   QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, 
                                   QMessageBox.StandardButton.No)

        if reply == QMessageBox.StandardButton.Yes:
            self.worker.stop()
            event.accept()
        else:
            event.ignore()

    def toggle_profile_blink(self):
        """ì €ì¥ ëª¨ë“œ ì‹œ ë²ˆí˜¸ ë²„íŠ¼ ì ë©¸ íš¨ê³¼"""
        self.is_profile_blink_on = not self.is_profile_blink_on
        color = "#ffc107" if self.is_profile_blink_on else "#f8f9fa"
        for btn in self.profile_buttons:
            btn.setStyleSheet(f"background-color: {color}; border: 2px solid #ffc107; border-radius: 4px; font-weight: bold; color: black; padding: 0px; font-size: 14px;")

    # [ë³µêµ¬] í•­ìƒ ìœ„ í† ê¸€ ë©”ì„œë“œ
    def toggle_always_on_top(self, checked):
        if checked:
            self.setWindowFlag(Qt.WindowType.WindowStaysOnTopHint, True)
            self.show()
        else:
            self.setWindowFlag(Qt.WindowType.WindowStaysOnTopHint, False)
            self.show()

if __name__ == '__main__':
    try:
        # [ì¶”ê°€] Windows ì‘ì—…í‘œì‹œì¤„ ì•„ì´ì½˜ ê³ ì • ë° í‘œì‹œë¥¼ ìœ„í•œ ID ì„¤ì •
        if sys.platform == 'win32':
            import ctypes
            myappid = 'kipo.buy.auto.4.2'
            ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myappid)

        app = QApplication(sys.argv)
        
        # Font Setup
        font = QFont("Malgun Gothic", 9)
        app.setFont(font)
        
        window = KipoWindow()
        window.show()
        
        retCode = app.exec()
        sys.exit(retCode)
        
    except BaseException as e:
        # BaseExceptionì„ í†µí•´ SystemExitê¹Œì§€ ëª¨ë‘ ìº¡ì²˜
        with open("crash_report.txt", "a", encoding="utf-8") as f:
            f.write(f"\n[{datetime.datetime.now()}] CRASH/EXIT LOGGED:\n")
            f.write(traceback.format_exc())
            f.write(f"Error Type: {type(e)}\n")
            f.write("-" * 50 + "\n")
        
        if not isinstance(e, SystemExit):
            # [ìˆ˜ì •] GUI ì•±ì´ë¯€ë¡œ ì½˜ì†” ì…ë ¥(input) ì œê±° + ë©”ì‹œì§€ ë°•ìŠ¤ ì‹œë„
            # Qt ì•±ì´ ì‚´ì•„ìˆë‹¤ë©´ ë©”ì‹œì§€ë°•ìŠ¤ë¥¼ ë„ìš°ì§€ë§Œ, ì£½ì—ˆì„ ìˆ˜ë„ ìˆìœ¼ë¯€ë¡œ ì•ˆì „í•˜ê²Œ íŒ¨ìŠ¤ í˜¹ì€ windows api ì‚¬ìš©
            try:
                import ctypes
                ctypes.windll.user32.MessageBoxW(0, f"Critical Error: {e}\nSee crash_report.txt", "Error", 0x10)
            except:
                pass
```
